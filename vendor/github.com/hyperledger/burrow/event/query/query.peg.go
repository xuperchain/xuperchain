package query

// Code generated by peg event/query/query.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	rulee
	ruleeor
	ruleeand
	rulecondition
	ruletag
	ruleqvalue
	rulevalue
	rulenumber
	ruledigit
	ruletime
	ruledate
	ruleyear
	rulemonth
	ruleday
	ruleand
	ruleor
	ruleequal
	rulecontains
	rulele
	rulege
	rulel
	ruleg
	ruleopen
	ruleclose
	rulesp
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	rulePegText
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
)

var rul3s = [...]string{
	"Unknown",
	"e",
	"eor",
	"eand",
	"condition",
	"tag",
	"qvalue",
	"value",
	"number",
	"digit",
	"time",
	"date",
	"year",
	"month",
	"day",
	"and",
	"or",
	"equal",
	"contains",
	"le",
	"ge",
	"l",
	"g",
	"open",
	"close",
	"sp",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"PegText",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type QueryParser struct {
	Expression

	Buffer string
	buffer []rune
	rules  [40]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *QueryParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *QueryParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *QueryParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *QueryParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *QueryParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *QueryParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.Operator(OpOr)
		case ruleAction1:
			p.Operator(OpAnd)
		case ruleAction2:
			p.Operator(OpLessEqual)
		case ruleAction3:
			p.Operator(OpGreaterEqual)
		case ruleAction4:
			p.Operator(OpLess)
		case ruleAction5:
			p.Operator(OpGreater)
		case ruleAction6:
			p.Operator(OpEqual)
		case ruleAction7:
			p.Operator(OpContains)
		case ruleAction8:
			p.Tag(buffer[begin:end])
		case ruleAction9:
			p.Value(buffer[begin:end])
		case ruleAction10:
			p.Number(buffer[begin:end])
		case ruleAction11:
			p.Time(buffer[begin:end])
		case ruleAction12:
			p.Date(buffer[begin:end])

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*QueryParser) error {
	return func(p *QueryParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*QueryParser) error {
	return func(p *QueryParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *QueryParser) Init(options ...func(*QueryParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 e <- <(eor !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleeor]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					if !matchDot() {
						goto l2
					}
					goto l0
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
				add(rulee, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 eor <- <(eand (or eand Action0)*)> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				if !_rules[ruleeand]() {
					goto l3
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if !_rules[ruleor]() {
						goto l6
					}
					if !_rules[ruleeand]() {
						goto l6
					}
					if !_rules[ruleAction0]() {
						goto l6
					}
					goto l5
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(ruleeor, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 eand <- <(condition (and condition Action1)*)> */
		func() bool {
			position7, tokenIndex7 := position, tokenIndex
			{
				position8 := position
				if !_rules[rulecondition]() {
					goto l7
				}
			l9:
				{
					position10, tokenIndex10 := position, tokenIndex
					if !_rules[ruleand]() {
						goto l10
					}
					if !_rules[rulecondition]() {
						goto l10
					}
					if !_rules[ruleAction1]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position10, tokenIndex10
				}
				add(ruleeand, position8)
			}
			return true
		l7:
			position, tokenIndex = position7, tokenIndex7
			return false
		},
		/* 3 condition <- <((tag sp ((le (number / time / date) Action2) / (ge (number / time / date) Action3) / (l (number / time / date) Action4) / (g (number / time / date) Action5) / (equal (number / time / date / qvalue) Action6) / (contains qvalue Action7)) sp) / (open eor close))> */
		func() bool {
			position11, tokenIndex11 := position, tokenIndex
			{
				position12 := position
				{
					position13, tokenIndex13 := position, tokenIndex
					if !_rules[ruletag]() {
						goto l14
					}
					if !_rules[rulesp]() {
						goto l14
					}
					{
						position15, tokenIndex15 := position, tokenIndex
						if !_rules[rulele]() {
							goto l16
						}
						{
							position17, tokenIndex17 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l18
							}
							goto l17
						l18:
							position, tokenIndex = position17, tokenIndex17
							if !_rules[ruletime]() {
								goto l19
							}
							goto l17
						l19:
							position, tokenIndex = position17, tokenIndex17
							if !_rules[ruledate]() {
								goto l16
							}
						}
					l17:
						if !_rules[ruleAction2]() {
							goto l16
						}
						goto l15
					l16:
						position, tokenIndex = position15, tokenIndex15
						if !_rules[rulege]() {
							goto l20
						}
						{
							position21, tokenIndex21 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l22
							}
							goto l21
						l22:
							position, tokenIndex = position21, tokenIndex21
							if !_rules[ruletime]() {
								goto l23
							}
							goto l21
						l23:
							position, tokenIndex = position21, tokenIndex21
							if !_rules[ruledate]() {
								goto l20
							}
						}
					l21:
						if !_rules[ruleAction3]() {
							goto l20
						}
						goto l15
					l20:
						position, tokenIndex = position15, tokenIndex15
						if !_rules[rulel]() {
							goto l24
						}
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l26
							}
							goto l25
						l26:
							position, tokenIndex = position25, tokenIndex25
							if !_rules[ruletime]() {
								goto l27
							}
							goto l25
						l27:
							position, tokenIndex = position25, tokenIndex25
							if !_rules[ruledate]() {
								goto l24
							}
						}
					l25:
						if !_rules[ruleAction4]() {
							goto l24
						}
						goto l15
					l24:
						position, tokenIndex = position15, tokenIndex15
						if !_rules[ruleg]() {
							goto l28
						}
						{
							position29, tokenIndex29 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l30
							}
							goto l29
						l30:
							position, tokenIndex = position29, tokenIndex29
							if !_rules[ruletime]() {
								goto l31
							}
							goto l29
						l31:
							position, tokenIndex = position29, tokenIndex29
							if !_rules[ruledate]() {
								goto l28
							}
						}
					l29:
						if !_rules[ruleAction5]() {
							goto l28
						}
						goto l15
					l28:
						position, tokenIndex = position15, tokenIndex15
						if !_rules[ruleequal]() {
							goto l32
						}
						{
							position33, tokenIndex33 := position, tokenIndex
							if !_rules[rulenumber]() {
								goto l34
							}
							goto l33
						l34:
							position, tokenIndex = position33, tokenIndex33
							if !_rules[ruletime]() {
								goto l35
							}
							goto l33
						l35:
							position, tokenIndex = position33, tokenIndex33
							if !_rules[ruledate]() {
								goto l36
							}
							goto l33
						l36:
							position, tokenIndex = position33, tokenIndex33
							if !_rules[ruleqvalue]() {
								goto l32
							}
						}
					l33:
						if !_rules[ruleAction6]() {
							goto l32
						}
						goto l15
					l32:
						position, tokenIndex = position15, tokenIndex15
						if !_rules[rulecontains]() {
							goto l14
						}
						if !_rules[ruleqvalue]() {
							goto l14
						}
						if !_rules[ruleAction7]() {
							goto l14
						}
					}
				l15:
					if !_rules[rulesp]() {
						goto l14
					}
					goto l13
				l14:
					position, tokenIndex = position13, tokenIndex13
					if !_rules[ruleopen]() {
						goto l11
					}
					if !_rules[ruleeor]() {
						goto l11
					}
					if !_rules[ruleclose]() {
						goto l11
					}
				}
			l13:
				add(rulecondition, position12)
			}
			return true
		l11:
			position, tokenIndex = position11, tokenIndex11
			return false
		},
		/* 4 tag <- <(<(!(' ' / '\t' / '\n' / '\r' / '\\' / '(' / ')' / '"' / '\'' / '=' / '>' / '<') .)+> sp Action8)> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				{
					position39 := position
					{
						position42, tokenIndex42 := position, tokenIndex
						{
							position43, tokenIndex43 := position, tokenIndex
							if buffer[position] != rune(' ') {
								goto l44
							}
							position++
							goto l43
						l44:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('\t') {
								goto l45
							}
							position++
							goto l43
						l45:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('\n') {
								goto l46
							}
							position++
							goto l43
						l46:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('\r') {
								goto l47
							}
							position++
							goto l43
						l47:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('\\') {
								goto l48
							}
							position++
							goto l43
						l48:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('(') {
								goto l49
							}
							position++
							goto l43
						l49:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune(')') {
								goto l50
							}
							position++
							goto l43
						l50:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('"') {
								goto l51
							}
							position++
							goto l43
						l51:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('\'') {
								goto l52
							}
							position++
							goto l43
						l52:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('=') {
								goto l53
							}
							position++
							goto l43
						l53:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('>') {
								goto l54
							}
							position++
							goto l43
						l54:
							position, tokenIndex = position43, tokenIndex43
							if buffer[position] != rune('<') {
								goto l42
							}
							position++
						}
					l43:
						goto l37
					l42:
						position, tokenIndex = position42, tokenIndex42
					}
					if !matchDot() {
						goto l37
					}
				l40:
					{
						position41, tokenIndex41 := position, tokenIndex
						{
							position55, tokenIndex55 := position, tokenIndex
							{
								position56, tokenIndex56 := position, tokenIndex
								if buffer[position] != rune(' ') {
									goto l57
								}
								position++
								goto l56
							l57:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('\t') {
									goto l58
								}
								position++
								goto l56
							l58:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('\n') {
									goto l59
								}
								position++
								goto l56
							l59:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('\r') {
									goto l60
								}
								position++
								goto l56
							l60:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('\\') {
									goto l61
								}
								position++
								goto l56
							l61:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('(') {
									goto l62
								}
								position++
								goto l56
							l62:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune(')') {
									goto l63
								}
								position++
								goto l56
							l63:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('"') {
									goto l64
								}
								position++
								goto l56
							l64:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('\'') {
									goto l65
								}
								position++
								goto l56
							l65:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('=') {
									goto l66
								}
								position++
								goto l56
							l66:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('>') {
									goto l67
								}
								position++
								goto l56
							l67:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('<') {
									goto l55
								}
								position++
							}
						l56:
							goto l41
						l55:
							position, tokenIndex = position55, tokenIndex55
						}
						if !matchDot() {
							goto l41
						}
						goto l40
					l41:
						position, tokenIndex = position41, tokenIndex41
					}
					add(rulePegText, position39)
				}
				if !_rules[rulesp]() {
					goto l37
				}
				if !_rules[ruleAction8]() {
					goto l37
				}
				add(ruletag, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 5 qvalue <- <('\'' value '\'' sp)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if buffer[position] != rune('\'') {
					goto l68
				}
				position++
				if !_rules[rulevalue]() {
					goto l68
				}
				if buffer[position] != rune('\'') {
					goto l68
				}
				position++
				if !_rules[rulesp]() {
					goto l68
				}
				add(ruleqvalue, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 6 value <- <(<(!('"' / '\'') .)*> Action9)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				{
					position72 := position
				l73:
					{
						position74, tokenIndex74 := position, tokenIndex
						{
							position75, tokenIndex75 := position, tokenIndex
							{
								position76, tokenIndex76 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l77
								}
								position++
								goto l76
							l77:
								position, tokenIndex = position76, tokenIndex76
								if buffer[position] != rune('\'') {
									goto l75
								}
								position++
							}
						l76:
							goto l74
						l75:
							position, tokenIndex = position75, tokenIndex75
						}
						if !matchDot() {
							goto l74
						}
						goto l73
					l74:
						position, tokenIndex = position74, tokenIndex74
					}
					add(rulePegText, position72)
				}
				if !_rules[ruleAction9]() {
					goto l70
				}
				add(rulevalue, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 7 number <- <(<('0' / ([1-9] digit* ('.' digit*)?))> Action10)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				{
					position80 := position
					{
						position81, tokenIndex81 := position, tokenIndex
						if buffer[position] != rune('0') {
							goto l82
						}
						position++
						goto l81
					l82:
						position, tokenIndex = position81, tokenIndex81
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l78
						}
						position++
					l83:
						{
							position84, tokenIndex84 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l84
							}
							goto l83
						l84:
							position, tokenIndex = position84, tokenIndex84
						}
						{
							position85, tokenIndex85 := position, tokenIndex
							if buffer[position] != rune('.') {
								goto l85
							}
							position++
						l87:
							{
								position88, tokenIndex88 := position, tokenIndex
								if !_rules[ruledigit]() {
									goto l88
								}
								goto l87
							l88:
								position, tokenIndex = position88, tokenIndex88
							}
							goto l86
						l85:
							position, tokenIndex = position85, tokenIndex85
						}
					l86:
					}
				l81:
					add(rulePegText, position80)
				}
				if !_rules[ruleAction10]() {
					goto l78
				}
				add(rulenumber, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 8 digit <- <[0-9]> */
		func() bool {
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l89
				}
				position++
				add(ruledigit, position90)
			}
			return true
		l89:
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 9 time <- <(('t' / 'T') ('i' / 'I') ('m' / 'M') ('e' / 'E') ' ' <(year '-' month '-' day 'T' digit digit ':' digit digit ':' digit digit ((('-' / '+') digit digit ':' digit digit) / 'Z'))> Action11)> */
		func() bool {
			position91, tokenIndex91 := position, tokenIndex
			{
				position92 := position
				{
					position93, tokenIndex93 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l94
					}
					position++
					goto l93
				l94:
					position, tokenIndex = position93, tokenIndex93
					if buffer[position] != rune('T') {
						goto l91
					}
					position++
				}
			l93:
				{
					position95, tokenIndex95 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l96
					}
					position++
					goto l95
				l96:
					position, tokenIndex = position95, tokenIndex95
					if buffer[position] != rune('I') {
						goto l91
					}
					position++
				}
			l95:
				{
					position97, tokenIndex97 := position, tokenIndex
					if buffer[position] != rune('m') {
						goto l98
					}
					position++
					goto l97
				l98:
					position, tokenIndex = position97, tokenIndex97
					if buffer[position] != rune('M') {
						goto l91
					}
					position++
				}
			l97:
				{
					position99, tokenIndex99 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l100
					}
					position++
					goto l99
				l100:
					position, tokenIndex = position99, tokenIndex99
					if buffer[position] != rune('E') {
						goto l91
					}
					position++
				}
			l99:
				if buffer[position] != rune(' ') {
					goto l91
				}
				position++
				{
					position101 := position
					if !_rules[ruleyear]() {
						goto l91
					}
					if buffer[position] != rune('-') {
						goto l91
					}
					position++
					if !_rules[rulemonth]() {
						goto l91
					}
					if buffer[position] != rune('-') {
						goto l91
					}
					position++
					if !_rules[ruleday]() {
						goto l91
					}
					if buffer[position] != rune('T') {
						goto l91
					}
					position++
					if !_rules[ruledigit]() {
						goto l91
					}
					if !_rules[ruledigit]() {
						goto l91
					}
					if buffer[position] != rune(':') {
						goto l91
					}
					position++
					if !_rules[ruledigit]() {
						goto l91
					}
					if !_rules[ruledigit]() {
						goto l91
					}
					if buffer[position] != rune(':') {
						goto l91
					}
					position++
					if !_rules[ruledigit]() {
						goto l91
					}
					if !_rules[ruledigit]() {
						goto l91
					}
					{
						position102, tokenIndex102 := position, tokenIndex
						{
							position104, tokenIndex104 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l105
							}
							position++
							goto l104
						l105:
							position, tokenIndex = position104, tokenIndex104
							if buffer[position] != rune('+') {
								goto l103
							}
							position++
						}
					l104:
						if !_rules[ruledigit]() {
							goto l103
						}
						if !_rules[ruledigit]() {
							goto l103
						}
						if buffer[position] != rune(':') {
							goto l103
						}
						position++
						if !_rules[ruledigit]() {
							goto l103
						}
						if !_rules[ruledigit]() {
							goto l103
						}
						goto l102
					l103:
						position, tokenIndex = position102, tokenIndex102
						if buffer[position] != rune('Z') {
							goto l91
						}
						position++
					}
				l102:
					add(rulePegText, position101)
				}
				if !_rules[ruleAction11]() {
					goto l91
				}
				add(ruletime, position92)
			}
			return true
		l91:
			position, tokenIndex = position91, tokenIndex91
			return false
		},
		/* 10 date <- <(('d' / 'D') ('a' / 'A') ('t' / 'T') ('e' / 'E') ' ' <(year '-' month '-' day)> Action12)> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				{
					position108, tokenIndex108 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l109
					}
					position++
					goto l108
				l109:
					position, tokenIndex = position108, tokenIndex108
					if buffer[position] != rune('D') {
						goto l106
					}
					position++
				}
			l108:
				{
					position110, tokenIndex110 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l111
					}
					position++
					goto l110
				l111:
					position, tokenIndex = position110, tokenIndex110
					if buffer[position] != rune('A') {
						goto l106
					}
					position++
				}
			l110:
				{
					position112, tokenIndex112 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l113
					}
					position++
					goto l112
				l113:
					position, tokenIndex = position112, tokenIndex112
					if buffer[position] != rune('T') {
						goto l106
					}
					position++
				}
			l112:
				{
					position114, tokenIndex114 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l115
					}
					position++
					goto l114
				l115:
					position, tokenIndex = position114, tokenIndex114
					if buffer[position] != rune('E') {
						goto l106
					}
					position++
				}
			l114:
				if buffer[position] != rune(' ') {
					goto l106
				}
				position++
				{
					position116 := position
					if !_rules[ruleyear]() {
						goto l106
					}
					if buffer[position] != rune('-') {
						goto l106
					}
					position++
					if !_rules[rulemonth]() {
						goto l106
					}
					if buffer[position] != rune('-') {
						goto l106
					}
					position++
					if !_rules[ruleday]() {
						goto l106
					}
					add(rulePegText, position116)
				}
				if !_rules[ruleAction12]() {
					goto l106
				}
				add(ruledate, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 11 year <- <(('1' / '2') digit digit digit)> */
		func() bool {
			position117, tokenIndex117 := position, tokenIndex
			{
				position118 := position
				{
					position119, tokenIndex119 := position, tokenIndex
					if buffer[position] != rune('1') {
						goto l120
					}
					position++
					goto l119
				l120:
					position, tokenIndex = position119, tokenIndex119
					if buffer[position] != rune('2') {
						goto l117
					}
					position++
				}
			l119:
				if !_rules[ruledigit]() {
					goto l117
				}
				if !_rules[ruledigit]() {
					goto l117
				}
				if !_rules[ruledigit]() {
					goto l117
				}
				add(ruleyear, position118)
			}
			return true
		l117:
			position, tokenIndex = position117, tokenIndex117
			return false
		},
		/* 12 month <- <(('0' / '1') digit)> */
		func() bool {
			position121, tokenIndex121 := position, tokenIndex
			{
				position122 := position
				{
					position123, tokenIndex123 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l124
					}
					position++
					goto l123
				l124:
					position, tokenIndex = position123, tokenIndex123
					if buffer[position] != rune('1') {
						goto l121
					}
					position++
				}
			l123:
				if !_rules[ruledigit]() {
					goto l121
				}
				add(rulemonth, position122)
			}
			return true
		l121:
			position, tokenIndex = position121, tokenIndex121
			return false
		},
		/* 13 day <- <(('0' / '1' / '2' / '3') digit)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127, tokenIndex127 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l128
					}
					position++
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					if buffer[position] != rune('1') {
						goto l129
					}
					position++
					goto l127
				l129:
					position, tokenIndex = position127, tokenIndex127
					if buffer[position] != rune('2') {
						goto l130
					}
					position++
					goto l127
				l130:
					position, tokenIndex = position127, tokenIndex127
					if buffer[position] != rune('3') {
						goto l125
					}
					position++
				}
			l127:
				if !_rules[ruledigit]() {
					goto l125
				}
				add(ruleday, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 14 and <- <(('a' / 'A') ('n' / 'N') ('d' / 'D') sp)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				{
					position133, tokenIndex133 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l134
					}
					position++
					goto l133
				l134:
					position, tokenIndex = position133, tokenIndex133
					if buffer[position] != rune('A') {
						goto l131
					}
					position++
				}
			l133:
				{
					position135, tokenIndex135 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l136
					}
					position++
					goto l135
				l136:
					position, tokenIndex = position135, tokenIndex135
					if buffer[position] != rune('N') {
						goto l131
					}
					position++
				}
			l135:
				{
					position137, tokenIndex137 := position, tokenIndex
					if buffer[position] != rune('d') {
						goto l138
					}
					position++
					goto l137
				l138:
					position, tokenIndex = position137, tokenIndex137
					if buffer[position] != rune('D') {
						goto l131
					}
					position++
				}
			l137:
				if !_rules[rulesp]() {
					goto l131
				}
				add(ruleand, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 15 or <- <(('o' / 'O') ('r' / 'R') sp)> */
		func() bool {
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				{
					position141, tokenIndex141 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l142
					}
					position++
					goto l141
				l142:
					position, tokenIndex = position141, tokenIndex141
					if buffer[position] != rune('O') {
						goto l139
					}
					position++
				}
			l141:
				{
					position143, tokenIndex143 := position, tokenIndex
					if buffer[position] != rune('r') {
						goto l144
					}
					position++
					goto l143
				l144:
					position, tokenIndex = position143, tokenIndex143
					if buffer[position] != rune('R') {
						goto l139
					}
					position++
				}
			l143:
				if !_rules[rulesp]() {
					goto l139
				}
				add(ruleor, position140)
			}
			return true
		l139:
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 16 equal <- <('=' sp)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('=') {
					goto l145
				}
				position++
				if !_rules[rulesp]() {
					goto l145
				}
				add(ruleequal, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 17 contains <- <(('c' / 'C') ('o' / 'O') ('n' / 'N') ('t' / 'T') ('a' / 'A') ('i' / 'I') ('n' / 'N') ('s' / 'S') sp)> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				{
					position149, tokenIndex149 := position, tokenIndex
					if buffer[position] != rune('c') {
						goto l150
					}
					position++
					goto l149
				l150:
					position, tokenIndex = position149, tokenIndex149
					if buffer[position] != rune('C') {
						goto l147
					}
					position++
				}
			l149:
				{
					position151, tokenIndex151 := position, tokenIndex
					if buffer[position] != rune('o') {
						goto l152
					}
					position++
					goto l151
				l152:
					position, tokenIndex = position151, tokenIndex151
					if buffer[position] != rune('O') {
						goto l147
					}
					position++
				}
			l151:
				{
					position153, tokenIndex153 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l154
					}
					position++
					goto l153
				l154:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('N') {
						goto l147
					}
					position++
				}
			l153:
				{
					position155, tokenIndex155 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l156
					}
					position++
					goto l155
				l156:
					position, tokenIndex = position155, tokenIndex155
					if buffer[position] != rune('T') {
						goto l147
					}
					position++
				}
			l155:
				{
					position157, tokenIndex157 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l158
					}
					position++
					goto l157
				l158:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('A') {
						goto l147
					}
					position++
				}
			l157:
				{
					position159, tokenIndex159 := position, tokenIndex
					if buffer[position] != rune('i') {
						goto l160
					}
					position++
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('I') {
						goto l147
					}
					position++
				}
			l159:
				{
					position161, tokenIndex161 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l162
					}
					position++
					goto l161
				l162:
					position, tokenIndex = position161, tokenIndex161
					if buffer[position] != rune('N') {
						goto l147
					}
					position++
				}
			l161:
				{
					position163, tokenIndex163 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l164
					}
					position++
					goto l163
				l164:
					position, tokenIndex = position163, tokenIndex163
					if buffer[position] != rune('S') {
						goto l147
					}
					position++
				}
			l163:
				if !_rules[rulesp]() {
					goto l147
				}
				add(rulecontains, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		/* 18 le <- <('<' '=' sp)> */
		func() bool {
			position165, tokenIndex165 := position, tokenIndex
			{
				position166 := position
				if buffer[position] != rune('<') {
					goto l165
				}
				position++
				if buffer[position] != rune('=') {
					goto l165
				}
				position++
				if !_rules[rulesp]() {
					goto l165
				}
				add(rulele, position166)
			}
			return true
		l165:
			position, tokenIndex = position165, tokenIndex165
			return false
		},
		/* 19 ge <- <('>' '=' sp)> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				if buffer[position] != rune('>') {
					goto l167
				}
				position++
				if buffer[position] != rune('=') {
					goto l167
				}
				position++
				if !_rules[rulesp]() {
					goto l167
				}
				add(rulege, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 20 l <- <('<' sp)> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				if buffer[position] != rune('<') {
					goto l169
				}
				position++
				if !_rules[rulesp]() {
					goto l169
				}
				add(rulel, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 21 g <- <('>' sp)> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				if buffer[position] != rune('>') {
					goto l171
				}
				position++
				if !_rules[rulesp]() {
					goto l171
				}
				add(ruleg, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 22 open <- <('(' sp)> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('(') {
					goto l173
				}
				position++
				if !_rules[rulesp]() {
					goto l173
				}
				add(ruleopen, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 23 close <- <(')' sp)> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				if buffer[position] != rune(')') {
					goto l175
				}
				position++
				if !_rules[rulesp]() {
					goto l175
				}
				add(ruleclose, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 24 sp <- <(' ' / '\t')*> */
		func() bool {
			{
				position178 := position
			l179:
				{
					position180, tokenIndex180 := position, tokenIndex
					{
						position181, tokenIndex181 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l182
						}
						position++
						goto l181
					l182:
						position, tokenIndex = position181, tokenIndex181
						if buffer[position] != rune('\t') {
							goto l180
						}
						position++
					}
				l181:
					goto l179
				l180:
					position, tokenIndex = position180, tokenIndex180
				}
				add(rulesp, position178)
			}
			return true
		},
		/* 26 Action0 <- <{ p.Operator(OpOr) }> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		/* 27 Action1 <- <{ p.Operator(OpAnd) }> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 28 Action2 <- <{ p.Operator(OpLessEqual) }> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 29 Action3 <- <{ p.Operator(OpGreaterEqual) }> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 30 Action4 <- <{ p.Operator(OpLess) }> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 31 Action5 <- <{ p.Operator(OpGreater) }> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 32 Action6 <- <{ p.Operator(OpEqual) }> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 33 Action7 <- <{ p.Operator(OpContains) }> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		nil,
		/* 35 Action8 <- <{ p.Tag(buffer[begin:end]) }> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 36 Action9 <- <{ p.Value(buffer[begin:end]) }> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 37 Action10 <- <{ p.Number(buffer[begin:end]) }> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 38 Action11 <- <{ p.Time(buffer[begin:end]) }> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 39 Action12 <- <{ p.Date(buffer[begin:end]) }> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
