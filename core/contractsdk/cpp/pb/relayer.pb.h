// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: relayer.proto

#ifndef PROTOBUF_INCLUDED_relayer_2eproto
#define PROTOBUF_INCLUDED_relayer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_relayer_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_relayer_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace relayer {
class InternalBlock;
class InternalBlockDefaultTypeInternal;
extern InternalBlockDefaultTypeInternal _InternalBlock_default_instance_;
class InternalBlock_FailedTxsEntry_DoNotUse;
class InternalBlock_FailedTxsEntry_DoNotUseDefaultTypeInternal;
extern InternalBlock_FailedTxsEntry_DoNotUseDefaultTypeInternal _InternalBlock_FailedTxsEntry_DoNotUse_default_instance_;
class InvokeRequest;
class InvokeRequestDefaultTypeInternal;
extern InvokeRequestDefaultTypeInternal _InvokeRequest_default_instance_;
class InvokeRequest_ArgsEntry_DoNotUse;
class InvokeRequest_ArgsEntry_DoNotUseDefaultTypeInternal;
extern InvokeRequest_ArgsEntry_DoNotUseDefaultTypeInternal _InvokeRequest_ArgsEntry_DoNotUse_default_instance_;
class LedgerMeta;
class LedgerMetaDefaultTypeInternal;
extern LedgerMetaDefaultTypeInternal _LedgerMeta_default_instance_;
class ModifyBlock;
class ModifyBlockDefaultTypeInternal;
extern ModifyBlockDefaultTypeInternal _ModifyBlock_default_instance_;
class QCSignInfos;
class QCSignInfosDefaultTypeInternal;
extern QCSignInfosDefaultTypeInternal _QCSignInfos_default_instance_;
class QuorumCert;
class QuorumCertDefaultTypeInternal;
extern QuorumCertDefaultTypeInternal _QuorumCert_default_instance_;
class ResourceLimit;
class ResourceLimitDefaultTypeInternal;
extern ResourceLimitDefaultTypeInternal _ResourceLimit_default_instance_;
class SignInfo;
class SignInfoDefaultTypeInternal;
extern SignInfoDefaultTypeInternal _SignInfo_default_instance_;
class SignatureInfo;
class SignatureInfoDefaultTypeInternal;
extern SignatureInfoDefaultTypeInternal _SignatureInfo_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TxInput;
class TxInputDefaultTypeInternal;
extern TxInputDefaultTypeInternal _TxInput_default_instance_;
class TxInputExt;
class TxInputExtDefaultTypeInternal;
extern TxInputExtDefaultTypeInternal _TxInputExt_default_instance_;
class TxOutput;
class TxOutputDefaultTypeInternal;
extern TxOutputDefaultTypeInternal _TxOutput_default_instance_;
class TxOutputExt;
class TxOutputExtDefaultTypeInternal;
extern TxOutputExtDefaultTypeInternal _TxOutputExt_default_instance_;
class XuperSignature;
class XuperSignatureDefaultTypeInternal;
extern XuperSignatureDefaultTypeInternal _XuperSignature_default_instance_;
}  // namespace relayer
namespace google {
namespace protobuf {
template<> ::relayer::InternalBlock* Arena::CreateMaybeMessage<::relayer::InternalBlock>(Arena*);
template<> ::relayer::InternalBlock_FailedTxsEntry_DoNotUse* Arena::CreateMaybeMessage<::relayer::InternalBlock_FailedTxsEntry_DoNotUse>(Arena*);
template<> ::relayer::InvokeRequest* Arena::CreateMaybeMessage<::relayer::InvokeRequest>(Arena*);
template<> ::relayer::InvokeRequest_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::relayer::InvokeRequest_ArgsEntry_DoNotUse>(Arena*);
template<> ::relayer::LedgerMeta* Arena::CreateMaybeMessage<::relayer::LedgerMeta>(Arena*);
template<> ::relayer::ModifyBlock* Arena::CreateMaybeMessage<::relayer::ModifyBlock>(Arena*);
template<> ::relayer::QCSignInfos* Arena::CreateMaybeMessage<::relayer::QCSignInfos>(Arena*);
template<> ::relayer::QuorumCert* Arena::CreateMaybeMessage<::relayer::QuorumCert>(Arena*);
template<> ::relayer::ResourceLimit* Arena::CreateMaybeMessage<::relayer::ResourceLimit>(Arena*);
template<> ::relayer::SignInfo* Arena::CreateMaybeMessage<::relayer::SignInfo>(Arena*);
template<> ::relayer::SignatureInfo* Arena::CreateMaybeMessage<::relayer::SignatureInfo>(Arena*);
template<> ::relayer::Transaction* Arena::CreateMaybeMessage<::relayer::Transaction>(Arena*);
template<> ::relayer::TxInput* Arena::CreateMaybeMessage<::relayer::TxInput>(Arena*);
template<> ::relayer::TxInputExt* Arena::CreateMaybeMessage<::relayer::TxInputExt>(Arena*);
template<> ::relayer::TxOutput* Arena::CreateMaybeMessage<::relayer::TxOutput>(Arena*);
template<> ::relayer::TxOutputExt* Arena::CreateMaybeMessage<::relayer::TxOutputExt>(Arena*);
template<> ::relayer::XuperSignature* Arena::CreateMaybeMessage<::relayer::XuperSignature>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace relayer {

enum ResourceType {
  CPU = 0,
  MEMORY = 1,
  DISK = 2,
  XFEE = 3,
  ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ResourceType_IsValid(int value);
const ResourceType ResourceType_MIN = CPU;
const ResourceType ResourceType_MAX = XFEE;
const int ResourceType_ARRAYSIZE = ResourceType_MAX + 1;

enum QCState {
  NEW_VIEW = 0,
  PREPARE = 1,
  PRE_COMMIT = 2,
  COMMIT = 3,
  DECIDE = 4,
  QCState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  QCState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool QCState_IsValid(int value);
const QCState QCState_MIN = NEW_VIEW;
const QCState QCState_MAX = DECIDE;
const int QCState_ARRAYSIZE = QCState_MAX + 1;

// ===================================================================

class InternalBlock_FailedTxsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<InternalBlock_FailedTxsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntryLite<InternalBlock_FailedTxsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  InternalBlock_FailedTxsEntry_DoNotUse();
  InternalBlock_FailedTxsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const InternalBlock_FailedTxsEntry_DoNotUse& other);
  static const InternalBlock_FailedTxsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InternalBlock_FailedTxsEntry_DoNotUse*>(&_InternalBlock_FailedTxsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class InternalBlock :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.InternalBlock) */ {
 public:
  InternalBlock();
  virtual ~InternalBlock();

  InternalBlock(const InternalBlock& from);

  inline InternalBlock& operator=(const InternalBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalBlock(InternalBlock&& from) noexcept
    : InternalBlock() {
    *this = ::std::move(from);
  }

  inline InternalBlock& operator=(InternalBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const InternalBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InternalBlock* internal_default_instance() {
    return reinterpret_cast<const InternalBlock*>(
               &_InternalBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(InternalBlock* other);
  friend void swap(InternalBlock& a, InternalBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalBlock* New() const final {
    return CreateMaybeMessage<InternalBlock>(nullptr);
  }

  InternalBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InternalBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InternalBlock& from);
  void MergeFrom(const InternalBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternalBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .relayer.Transaction transactions = 11;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 11;
  ::relayer::Transaction* mutable_transactions(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::Transaction >*
      mutable_transactions();
  const ::relayer::Transaction& transactions(int index) const;
  ::relayer::Transaction* add_transactions();
  const ::google::protobuf::RepeatedPtrField< ::relayer::Transaction >&
      transactions() const;

  // repeated bytes merkle_tree = 13;
  int merkle_tree_size() const;
  void clear_merkle_tree();
  static const int kMerkleTreeFieldNumber = 13;
  const ::std::string& merkle_tree(int index) const;
  ::std::string* mutable_merkle_tree(int index);
  void set_merkle_tree(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_merkle_tree(int index, ::std::string&& value);
  #endif
  void set_merkle_tree(int index, const char* value);
  void set_merkle_tree(int index, const void* value, size_t size);
  ::std::string* add_merkle_tree();
  void add_merkle_tree(const ::std::string& value);
  #if LANG_CXX11
  void add_merkle_tree(::std::string&& value);
  #endif
  void add_merkle_tree(const char* value);
  void add_merkle_tree(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& merkle_tree() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_merkle_tree();

  // map<string, string> failed_txs = 18;
  int failed_txs_size() const;
  void clear_failed_txs();
  static const int kFailedTxsFieldNumber = 18;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      failed_txs() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_failed_txs();

  // bytes blockid = 3;
  void clear_blockid();
  static const int kBlockidFieldNumber = 3;
  const ::std::string& blockid() const;
  void set_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockid(::std::string&& value);
  #endif
  void set_blockid(const char* value);
  void set_blockid(const void* value, size_t size);
  ::std::string* mutable_blockid();
  ::std::string* release_blockid();
  void set_allocated_blockid(::std::string* blockid);

  // bytes pre_hash = 4;
  void clear_pre_hash();
  static const int kPreHashFieldNumber = 4;
  const ::std::string& pre_hash() const;
  void set_pre_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_pre_hash(::std::string&& value);
  #endif
  void set_pre_hash(const char* value);
  void set_pre_hash(const void* value, size_t size);
  ::std::string* mutable_pre_hash();
  ::std::string* release_pre_hash();
  void set_allocated_pre_hash(::std::string* pre_hash);

  // bytes proposer = 5;
  void clear_proposer();
  static const int kProposerFieldNumber = 5;
  const ::std::string& proposer() const;
  void set_proposer(const ::std::string& value);
  #if LANG_CXX11
  void set_proposer(::std::string&& value);
  #endif
  void set_proposer(const char* value);
  void set_proposer(const void* value, size_t size);
  ::std::string* mutable_proposer();
  ::std::string* release_proposer();
  void set_allocated_proposer(::std::string* proposer);

  // bytes sign = 6;
  void clear_sign();
  static const int kSignFieldNumber = 6;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const void* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // bytes pubkey = 7;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 7;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // bytes merkle_root = 8;
  void clear_merkle_root();
  static const int kMerkleRootFieldNumber = 8;
  const ::std::string& merkle_root() const;
  void set_merkle_root(const ::std::string& value);
  #if LANG_CXX11
  void set_merkle_root(::std::string&& value);
  #endif
  void set_merkle_root(const char* value);
  void set_merkle_root(const void* value, size_t size);
  ::std::string* mutable_merkle_root();
  ::std::string* release_merkle_root();
  void set_allocated_merkle_root(::std::string* merkle_root);

  // bytes next_hash = 15;
  void clear_next_hash();
  static const int kNextHashFieldNumber = 15;
  const ::std::string& next_hash() const;
  void set_next_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_next_hash(::std::string&& value);
  #endif
  void set_next_hash(const char* value);
  void set_next_hash(const void* value, size_t size);
  ::std::string* mutable_next_hash();
  ::std::string* release_next_hash();
  void set_allocated_next_hash(::std::string* next_hash);

  // .relayer.QuorumCert Justify = 20;
  bool has_justify() const;
  void clear_justify();
  static const int kJustifyFieldNumber = 20;
  const ::relayer::QuorumCert& justify() const;
  ::relayer::QuorumCert* release_justify();
  ::relayer::QuorumCert* mutable_justify();
  void set_allocated_justify(::relayer::QuorumCert* justify);

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::int32 nonce() const;
  void set_nonce(::google::protobuf::int32 value);

  // int64 height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 timestamp = 10;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 tx_count = 12;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 12;
  ::google::protobuf::int32 tx_count() const;
  void set_tx_count(::google::protobuf::int32 value);

  // bool in_trunk = 14;
  void clear_in_trunk();
  static const int kInTrunkFieldNumber = 14;
  bool in_trunk() const;
  void set_in_trunk(bool value);

  // int64 curTerm = 16;
  void clear_curterm();
  static const int kCurTermFieldNumber = 16;
  ::google::protobuf::int64 curterm() const;
  void set_curterm(::google::protobuf::int64 value);

  // int64 curBlockNum = 17;
  void clear_curblocknum();
  static const int kCurBlockNumFieldNumber = 17;
  ::google::protobuf::int64 curblocknum() const;
  void set_curblocknum(::google::protobuf::int64 value);

  // int32 targetBits = 19;
  void clear_targetbits();
  static const int kTargetBitsFieldNumber = 19;
  ::google::protobuf::int32 targetbits() const;
  void set_targetbits(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:relayer.InternalBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::relayer::Transaction > transactions_;
  ::google::protobuf::RepeatedPtrField<::std::string> merkle_tree_;
  ::google::protobuf::internal::MapFieldLite<
      InternalBlock_FailedTxsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > failed_txs_;
  ::google::protobuf::internal::ArenaStringPtr blockid_;
  ::google::protobuf::internal::ArenaStringPtr pre_hash_;
  ::google::protobuf::internal::ArenaStringPtr proposer_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr merkle_root_;
  ::google::protobuf::internal::ArenaStringPtr next_hash_;
  ::relayer::QuorumCert* justify_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 nonce_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 tx_count_;
  bool in_trunk_;
  ::google::protobuf::int64 curterm_;
  ::google::protobuf::int64 curblocknum_;
  ::google::protobuf::int32 targetbits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class Transaction :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .relayer.TxInput tx_inputs = 3;
  int tx_inputs_size() const;
  void clear_tx_inputs();
  static const int kTxInputsFieldNumber = 3;
  ::relayer::TxInput* mutable_tx_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::TxInput >*
      mutable_tx_inputs();
  const ::relayer::TxInput& tx_inputs(int index) const;
  ::relayer::TxInput* add_tx_inputs();
  const ::google::protobuf::RepeatedPtrField< ::relayer::TxInput >&
      tx_inputs() const;

  // repeated .relayer.TxOutput tx_outputs = 4;
  int tx_outputs_size() const;
  void clear_tx_outputs();
  static const int kTxOutputsFieldNumber = 4;
  ::relayer::TxOutput* mutable_tx_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::TxOutput >*
      mutable_tx_outputs();
  const ::relayer::TxOutput& tx_outputs(int index) const;
  ::relayer::TxOutput* add_tx_outputs();
  const ::google::protobuf::RepeatedPtrField< ::relayer::TxOutput >&
      tx_outputs() const;

  // repeated .relayer.TxInputExt tx_inputs_ext = 23;
  int tx_inputs_ext_size() const;
  void clear_tx_inputs_ext();
  static const int kTxInputsExtFieldNumber = 23;
  ::relayer::TxInputExt* mutable_tx_inputs_ext(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::TxInputExt >*
      mutable_tx_inputs_ext();
  const ::relayer::TxInputExt& tx_inputs_ext(int index) const;
  ::relayer::TxInputExt* add_tx_inputs_ext();
  const ::google::protobuf::RepeatedPtrField< ::relayer::TxInputExt >&
      tx_inputs_ext() const;

  // repeated .relayer.TxOutputExt tx_outputs_ext = 24;
  int tx_outputs_ext_size() const;
  void clear_tx_outputs_ext();
  static const int kTxOutputsExtFieldNumber = 24;
  ::relayer::TxOutputExt* mutable_tx_outputs_ext(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::TxOutputExt >*
      mutable_tx_outputs_ext();
  const ::relayer::TxOutputExt& tx_outputs_ext(int index) const;
  ::relayer::TxOutputExt* add_tx_outputs_ext();
  const ::google::protobuf::RepeatedPtrField< ::relayer::TxOutputExt >&
      tx_outputs_ext() const;

  // repeated .relayer.InvokeRequest contract_requests = 25;
  int contract_requests_size() const;
  void clear_contract_requests();
  static const int kContractRequestsFieldNumber = 25;
  ::relayer::InvokeRequest* mutable_contract_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::InvokeRequest >*
      mutable_contract_requests();
  const ::relayer::InvokeRequest& contract_requests(int index) const;
  ::relayer::InvokeRequest* add_contract_requests();
  const ::google::protobuf::RepeatedPtrField< ::relayer::InvokeRequest >&
      contract_requests() const;

  // repeated string auth_require = 27;
  int auth_require_size() const;
  void clear_auth_require();
  static const int kAuthRequireFieldNumber = 27;
  const ::std::string& auth_require(int index) const;
  ::std::string* mutable_auth_require(int index);
  void set_auth_require(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_auth_require(int index, ::std::string&& value);
  #endif
  void set_auth_require(int index, const char* value);
  void set_auth_require(int index, const char* value, size_t size);
  ::std::string* add_auth_require();
  void add_auth_require(const ::std::string& value);
  #if LANG_CXX11
  void add_auth_require(::std::string&& value);
  #endif
  void add_auth_require(const char* value);
  void add_auth_require(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& auth_require() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_auth_require();

  // repeated .relayer.SignatureInfo initiator_signs = 28;
  int initiator_signs_size() const;
  void clear_initiator_signs();
  static const int kInitiatorSignsFieldNumber = 28;
  ::relayer::SignatureInfo* mutable_initiator_signs(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >*
      mutable_initiator_signs();
  const ::relayer::SignatureInfo& initiator_signs(int index) const;
  ::relayer::SignatureInfo* add_initiator_signs();
  const ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >&
      initiator_signs() const;

  // repeated .relayer.SignatureInfo auth_require_signs = 29;
  int auth_require_signs_size() const;
  void clear_auth_require_signs();
  static const int kAuthRequireSignsFieldNumber = 29;
  ::relayer::SignatureInfo* mutable_auth_require_signs(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >*
      mutable_auth_require_signs();
  const ::relayer::SignatureInfo& auth_require_signs(int index) const;
  ::relayer::SignatureInfo* add_auth_require_signs();
  const ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >&
      auth_require_signs() const;

  // bytes txid = 1;
  void clear_txid();
  static const int kTxidFieldNumber = 1;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const void* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // bytes blockid = 2;
  void clear_blockid();
  static const int kBlockidFieldNumber = 2;
  const ::std::string& blockid() const;
  void set_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockid(::std::string&& value);
  #endif
  void set_blockid(const char* value);
  void set_blockid(const void* value, size_t size);
  ::std::string* mutable_blockid();
  ::std::string* release_blockid();
  void set_allocated_blockid(::std::string* blockid);

  // bytes desc = 6;
  void clear_desc();
  static const int kDescFieldNumber = 6;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // string nonce = 8;
  void clear_nonce();
  static const int kNonceFieldNumber = 8;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const char* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // string initiator = 26;
  void clear_initiator();
  static const int kInitiatorFieldNumber = 26;
  const ::std::string& initiator() const;
  void set_initiator(const ::std::string& value);
  #if LANG_CXX11
  void set_initiator(::std::string&& value);
  #endif
  void set_initiator(const char* value);
  void set_initiator(const char* value, size_t size);
  ::std::string* mutable_initiator();
  ::std::string* release_initiator();
  void set_allocated_initiator(::std::string* initiator);

  // .relayer.XuperSignature xuper_sign = 31;
  bool has_xuper_sign() const;
  void clear_xuper_sign();
  static const int kXuperSignFieldNumber = 31;
  const ::relayer::XuperSignature& xuper_sign() const;
  ::relayer::XuperSignature* release_xuper_sign();
  ::relayer::XuperSignature* mutable_xuper_sign();
  void set_allocated_xuper_sign(::relayer::XuperSignature* xuper_sign);

  // .relayer.ModifyBlock modify_block = 32;
  bool has_modify_block() const;
  void clear_modify_block();
  static const int kModifyBlockFieldNumber = 32;
  const ::relayer::ModifyBlock& modify_block() const;
  ::relayer::ModifyBlock* release_modify_block();
  ::relayer::ModifyBlock* mutable_modify_block();
  void set_allocated_modify_block(::relayer::ModifyBlock* modify_block);

  // int64 timestamp = 9;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // bool coinbase = 7;
  void clear_coinbase();
  static const int kCoinbaseFieldNumber = 7;
  bool coinbase() const;
  void set_coinbase(bool value);

  // bool autogen = 11;
  void clear_autogen();
  static const int kAutogenFieldNumber = 11;
  bool autogen() const;
  void set_autogen(bool value);

  // int32 version = 10;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int64 received_timestamp = 30;
  void clear_received_timestamp();
  static const int kReceivedTimestampFieldNumber = 30;
  ::google::protobuf::int64 received_timestamp() const;
  void set_received_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:relayer.Transaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::relayer::TxInput > tx_inputs_;
  ::google::protobuf::RepeatedPtrField< ::relayer::TxOutput > tx_outputs_;
  ::google::protobuf::RepeatedPtrField< ::relayer::TxInputExt > tx_inputs_ext_;
  ::google::protobuf::RepeatedPtrField< ::relayer::TxOutputExt > tx_outputs_ext_;
  ::google::protobuf::RepeatedPtrField< ::relayer::InvokeRequest > contract_requests_;
  ::google::protobuf::RepeatedPtrField<::std::string> auth_require_;
  ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo > initiator_signs_;
  ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo > auth_require_signs_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::google::protobuf::internal::ArenaStringPtr blockid_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::internal::ArenaStringPtr initiator_;
  ::relayer::XuperSignature* xuper_sign_;
  ::relayer::ModifyBlock* modify_block_;
  ::google::protobuf::int64 timestamp_;
  bool coinbase_;
  bool autogen_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int64 received_timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class TxInput :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.TxInput) */ {
 public:
  TxInput();
  virtual ~TxInput();

  TxInput(const TxInput& from);

  inline TxInput& operator=(const TxInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxInput(TxInput&& from) noexcept
    : TxInput() {
    *this = ::std::move(from);
  }

  inline TxInput& operator=(TxInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxInput* internal_default_instance() {
    return reinterpret_cast<const TxInput*>(
               &_TxInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TxInput* other);
  friend void swap(TxInput& a, TxInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxInput* New() const final {
    return CreateMaybeMessage<TxInput>(nullptr);
  }

  TxInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxInput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxInput& from);
  void MergeFrom(const TxInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes ref_txid = 1;
  void clear_ref_txid();
  static const int kRefTxidFieldNumber = 1;
  const ::std::string& ref_txid() const;
  void set_ref_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_txid(::std::string&& value);
  #endif
  void set_ref_txid(const char* value);
  void set_ref_txid(const void* value, size_t size);
  ::std::string* mutable_ref_txid();
  ::std::string* release_ref_txid();
  void set_allocated_ref_txid(::std::string* ref_txid);

  // bytes from_addr = 5;
  void clear_from_addr();
  static const int kFromAddrFieldNumber = 5;
  const ::std::string& from_addr() const;
  void set_from_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_from_addr(::std::string&& value);
  #endif
  void set_from_addr(const char* value);
  void set_from_addr(const void* value, size_t size);
  ::std::string* mutable_from_addr();
  ::std::string* release_from_addr();
  void set_allocated_from_addr(::std::string* from_addr);

  // bytes amount = 6;
  void clear_amount();
  static const int kAmountFieldNumber = 6;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const void* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // int32 ref_offset = 2;
  void clear_ref_offset();
  static const int kRefOffsetFieldNumber = 2;
  ::google::protobuf::int32 ref_offset() const;
  void set_ref_offset(::google::protobuf::int32 value);

  // int64 frozen_height = 7;
  void clear_frozen_height();
  static const int kFrozenHeightFieldNumber = 7;
  ::google::protobuf::int64 frozen_height() const;
  void set_frozen_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:relayer.TxInput)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ref_txid_;
  ::google::protobuf::internal::ArenaStringPtr from_addr_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::int32 ref_offset_;
  ::google::protobuf::int64 frozen_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class TxOutput :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.TxOutput) */ {
 public:
  TxOutput();
  virtual ~TxOutput();

  TxOutput(const TxOutput& from);

  inline TxOutput& operator=(const TxOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxOutput(TxOutput&& from) noexcept
    : TxOutput() {
    *this = ::std::move(from);
  }

  inline TxOutput& operator=(TxOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxOutput* internal_default_instance() {
    return reinterpret_cast<const TxOutput*>(
               &_TxOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TxOutput* other);
  friend void swap(TxOutput& a, TxOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxOutput* New() const final {
    return CreateMaybeMessage<TxOutput>(nullptr);
  }

  TxOutput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxOutput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxOutput& from);
  void MergeFrom(const TxOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes amount = 1;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const void* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // bytes to_addr = 2;
  void clear_to_addr();
  static const int kToAddrFieldNumber = 2;
  const ::std::string& to_addr() const;
  void set_to_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_to_addr(::std::string&& value);
  #endif
  void set_to_addr(const char* value);
  void set_to_addr(const void* value, size_t size);
  ::std::string* mutable_to_addr();
  ::std::string* release_to_addr();
  void set_allocated_to_addr(::std::string* to_addr);

  // int64 frozen_height = 4;
  void clear_frozen_height();
  static const int kFrozenHeightFieldNumber = 4;
  ::google::protobuf::int64 frozen_height() const;
  void set_frozen_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:relayer.TxOutput)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::internal::ArenaStringPtr to_addr_;
  ::google::protobuf::int64 frozen_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class TxInputExt :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.TxInputExt) */ {
 public:
  TxInputExt();
  virtual ~TxInputExt();

  TxInputExt(const TxInputExt& from);

  inline TxInputExt& operator=(const TxInputExt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxInputExt(TxInputExt&& from) noexcept
    : TxInputExt() {
    *this = ::std::move(from);
  }

  inline TxInputExt& operator=(TxInputExt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxInputExt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxInputExt* internal_default_instance() {
    return reinterpret_cast<const TxInputExt*>(
               &_TxInputExt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TxInputExt* other);
  friend void swap(TxInputExt& a, TxInputExt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxInputExt* New() const final {
    return CreateMaybeMessage<TxInputExt>(nullptr);
  }

  TxInputExt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxInputExt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxInputExt& from);
  void MergeFrom(const TxInputExt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxInputExt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes ref_txid = 3;
  void clear_ref_txid();
  static const int kRefTxidFieldNumber = 3;
  const ::std::string& ref_txid() const;
  void set_ref_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_txid(::std::string&& value);
  #endif
  void set_ref_txid(const char* value);
  void set_ref_txid(const void* value, size_t size);
  ::std::string* mutable_ref_txid();
  ::std::string* release_ref_txid();
  void set_allocated_ref_txid(::std::string* ref_txid);

  // int32 ref_offset = 4;
  void clear_ref_offset();
  static const int kRefOffsetFieldNumber = 4;
  ::google::protobuf::int32 ref_offset() const;
  void set_ref_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:relayer.TxInputExt)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr ref_txid_;
  ::google::protobuf::int32 ref_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class TxOutputExt :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.TxOutputExt) */ {
 public:
  TxOutputExt();
  virtual ~TxOutputExt();

  TxOutputExt(const TxOutputExt& from);

  inline TxOutputExt& operator=(const TxOutputExt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxOutputExt(TxOutputExt&& from) noexcept
    : TxOutputExt() {
    *this = ::std::move(from);
  }

  inline TxOutputExt& operator=(TxOutputExt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxOutputExt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxOutputExt* internal_default_instance() {
    return reinterpret_cast<const TxOutputExt*>(
               &_TxOutputExt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TxOutputExt* other);
  friend void swap(TxOutputExt& a, TxOutputExt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxOutputExt* New() const final {
    return CreateMaybeMessage<TxOutputExt>(nullptr);
  }

  TxOutputExt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxOutputExt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxOutputExt& from);
  void MergeFrom(const TxOutputExt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxOutputExt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bucket = 1;
  void clear_bucket();
  static const int kBucketFieldNumber = 1;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:relayer.TxOutputExt)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class InvokeRequest_ArgsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<InvokeRequest_ArgsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntryLite<InvokeRequest_ArgsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  InvokeRequest_ArgsEntry_DoNotUse();
  InvokeRequest_ArgsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const InvokeRequest_ArgsEntry_DoNotUse& other);
  static const InvokeRequest_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InvokeRequest_ArgsEntry_DoNotUse*>(&_InvokeRequest_ArgsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class InvokeRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.InvokeRequest) */ {
 public:
  InvokeRequest();
  virtual ~InvokeRequest();

  InvokeRequest(const InvokeRequest& from);

  inline InvokeRequest& operator=(const InvokeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvokeRequest(InvokeRequest&& from) noexcept
    : InvokeRequest() {
    *this = ::std::move(from);
  }

  inline InvokeRequest& operator=(InvokeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const InvokeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvokeRequest* internal_default_instance() {
    return reinterpret_cast<const InvokeRequest*>(
               &_InvokeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(InvokeRequest* other);
  friend void swap(InvokeRequest& a, InvokeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvokeRequest* New() const final {
    return CreateMaybeMessage<InvokeRequest>(nullptr);
  }

  InvokeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvokeRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InvokeRequest& from);
  void MergeFrom(const InvokeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvokeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> args = 4;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      args() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_args();

  // repeated .relayer.ResourceLimit resource_limits = 5;
  int resource_limits_size() const;
  void clear_resource_limits();
  static const int kResourceLimitsFieldNumber = 5;
  ::relayer::ResourceLimit* mutable_resource_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::ResourceLimit >*
      mutable_resource_limits();
  const ::relayer::ResourceLimit& resource_limits(int index) const;
  ::relayer::ResourceLimit* add_resource_limits();
  const ::google::protobuf::RepeatedPtrField< ::relayer::ResourceLimit >&
      resource_limits() const;

  // string module_name = 1;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  const ::std::string& module_name() const;
  void set_module_name(const ::std::string& value);
  #if LANG_CXX11
  void set_module_name(::std::string&& value);
  #endif
  void set_module_name(const char* value);
  void set_module_name(const char* value, size_t size);
  ::std::string* mutable_module_name();
  ::std::string* release_module_name();
  void set_allocated_module_name(::std::string* module_name);

  // string contract_name = 2;
  void clear_contract_name();
  static const int kContractNameFieldNumber = 2;
  const ::std::string& contract_name() const;
  void set_contract_name(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_name(::std::string&& value);
  #endif
  void set_contract_name(const char* value);
  void set_contract_name(const char* value, size_t size);
  ::std::string* mutable_contract_name();
  ::std::string* release_contract_name();
  void set_allocated_contract_name(::std::string* contract_name);

  // string method_name = 3;
  void clear_method_name();
  static const int kMethodNameFieldNumber = 3;
  const ::std::string& method_name() const;
  void set_method_name(const ::std::string& value);
  #if LANG_CXX11
  void set_method_name(::std::string&& value);
  #endif
  void set_method_name(const char* value);
  void set_method_name(const char* value, size_t size);
  ::std::string* mutable_method_name();
  ::std::string* release_method_name();
  void set_allocated_method_name(::std::string* method_name);

  // string amount = 6;
  void clear_amount();
  static const int kAmountFieldNumber = 6;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // @@protoc_insertion_point(class_scope:relayer.InvokeRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      InvokeRequest_ArgsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > args_;
  ::google::protobuf::RepeatedPtrField< ::relayer::ResourceLimit > resource_limits_;
  ::google::protobuf::internal::ArenaStringPtr module_name_;
  ::google::protobuf::internal::ArenaStringPtr contract_name_;
  ::google::protobuf::internal::ArenaStringPtr method_name_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class SignatureInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.SignatureInfo) */ {
 public:
  SignatureInfo();
  virtual ~SignatureInfo();

  SignatureInfo(const SignatureInfo& from);

  inline SignatureInfo& operator=(const SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignatureInfo(SignatureInfo&& from) noexcept
    : SignatureInfo() {
    *this = ::std::move(from);
  }

  inline SignatureInfo& operator=(SignatureInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SignatureInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignatureInfo* internal_default_instance() {
    return reinterpret_cast<const SignatureInfo*>(
               &_SignatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SignatureInfo* other);
  friend void swap(SignatureInfo& a, SignatureInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignatureInfo* New() const final {
    return CreateMaybeMessage<SignatureInfo>(nullptr);
  }

  SignatureInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignatureInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SignatureInfo& from);
  void MergeFrom(const SignatureInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignatureInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string PublicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  #if LANG_CXX11
  void set_publickey(::std::string&& value);
  #endif
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // bytes Sign = 2;
  void clear_sign();
  static const int kSignFieldNumber = 2;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const void* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // @@protoc_insertion_point(class_scope:relayer.SignatureInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class XuperSignature :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.XuperSignature) */ {
 public:
  XuperSignature();
  virtual ~XuperSignature();

  XuperSignature(const XuperSignature& from);

  inline XuperSignature& operator=(const XuperSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XuperSignature(XuperSignature&& from) noexcept
    : XuperSignature() {
    *this = ::std::move(from);
  }

  inline XuperSignature& operator=(XuperSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const XuperSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XuperSignature* internal_default_instance() {
    return reinterpret_cast<const XuperSignature*>(
               &_XuperSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(XuperSignature* other);
  friend void swap(XuperSignature& a, XuperSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XuperSignature* New() const final {
    return CreateMaybeMessage<XuperSignature>(nullptr);
  }

  XuperSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XuperSignature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const XuperSignature& from);
  void MergeFrom(const XuperSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XuperSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes public_keys = 1;
  int public_keys_size() const;
  void clear_public_keys();
  static const int kPublicKeysFieldNumber = 1;
  const ::std::string& public_keys(int index) const;
  ::std::string* mutable_public_keys(int index);
  void set_public_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_public_keys(int index, ::std::string&& value);
  #endif
  void set_public_keys(int index, const char* value);
  void set_public_keys(int index, const void* value, size_t size);
  ::std::string* add_public_keys();
  void add_public_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_public_keys(::std::string&& value);
  #endif
  void add_public_keys(const char* value);
  void add_public_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& public_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_public_keys();

  // bytes signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:relayer.XuperSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> public_keys_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class ModifyBlock :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.ModifyBlock) */ {
 public:
  ModifyBlock();
  virtual ~ModifyBlock();

  ModifyBlock(const ModifyBlock& from);

  inline ModifyBlock& operator=(const ModifyBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModifyBlock(ModifyBlock&& from) noexcept
    : ModifyBlock() {
    *this = ::std::move(from);
  }

  inline ModifyBlock& operator=(ModifyBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ModifyBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyBlock* internal_default_instance() {
    return reinterpret_cast<const ModifyBlock*>(
               &_ModifyBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ModifyBlock* other);
  friend void swap(ModifyBlock& a, ModifyBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModifyBlock* New() const final {
    return CreateMaybeMessage<ModifyBlock>(nullptr);
  }

  ModifyBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModifyBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ModifyBlock& from);
  void MergeFrom(const ModifyBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModifyBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string effective_txid = 1;
  void clear_effective_txid();
  static const int kEffectiveTxidFieldNumber = 1;
  const ::std::string& effective_txid() const;
  void set_effective_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_effective_txid(::std::string&& value);
  #endif
  void set_effective_txid(const char* value);
  void set_effective_txid(const char* value, size_t size);
  ::std::string* mutable_effective_txid();
  ::std::string* release_effective_txid();
  void set_allocated_effective_txid(::std::string* effective_txid);

  // string public_key = 4;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string sign = 5;
  void clear_sign();
  static const int kSignFieldNumber = 5;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const char* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // int64 effective_height = 3;
  void clear_effective_height();
  static const int kEffectiveHeightFieldNumber = 3;
  ::google::protobuf::int64 effective_height() const;
  void set_effective_height(::google::protobuf::int64 value);

  // bool marked = 2;
  void clear_marked();
  static const int kMarkedFieldNumber = 2;
  bool marked() const;
  void set_marked(bool value);

  // @@protoc_insertion_point(class_scope:relayer.ModifyBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr effective_txid_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  ::google::protobuf::int64 effective_height_;
  bool marked_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class ResourceLimit :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.ResourceLimit) */ {
 public:
  ResourceLimit();
  virtual ~ResourceLimit();

  ResourceLimit(const ResourceLimit& from);

  inline ResourceLimit& operator=(const ResourceLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceLimit(ResourceLimit&& from) noexcept
    : ResourceLimit() {
    *this = ::std::move(from);
  }

  inline ResourceLimit& operator=(ResourceLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResourceLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceLimit* internal_default_instance() {
    return reinterpret_cast<const ResourceLimit*>(
               &_ResourceLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ResourceLimit* other);
  friend void swap(ResourceLimit& a, ResourceLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceLimit* New() const final {
    return CreateMaybeMessage<ResourceLimit>(nullptr);
  }

  ResourceLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceLimit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResourceLimit& from);
  void MergeFrom(const ResourceLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResourceLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // .relayer.ResourceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::relayer::ResourceType type() const;
  void set_type(::relayer::ResourceType value);

  // @@protoc_insertion_point(class_scope:relayer.ResourceLimit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 limit_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class QuorumCert :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.QuorumCert) */ {
 public:
  QuorumCert();
  virtual ~QuorumCert();

  QuorumCert(const QuorumCert& from);

  inline QuorumCert& operator=(const QuorumCert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuorumCert(QuorumCert&& from) noexcept
    : QuorumCert() {
    *this = ::std::move(from);
  }

  inline QuorumCert& operator=(QuorumCert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QuorumCert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuorumCert* internal_default_instance() {
    return reinterpret_cast<const QuorumCert*>(
               &_QuorumCert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(QuorumCert* other);
  friend void swap(QuorumCert& a, QuorumCert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuorumCert* New() const final {
    return CreateMaybeMessage<QuorumCert>(nullptr);
  }

  QuorumCert* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QuorumCert>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QuorumCert& from);
  void MergeFrom(const QuorumCert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QuorumCert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes ProposalId = 1;
  void clear_proposalid();
  static const int kProposalIdFieldNumber = 1;
  const ::std::string& proposalid() const;
  void set_proposalid(const ::std::string& value);
  #if LANG_CXX11
  void set_proposalid(::std::string&& value);
  #endif
  void set_proposalid(const char* value);
  void set_proposalid(const void* value, size_t size);
  ::std::string* mutable_proposalid();
  ::std::string* release_proposalid();
  void set_allocated_proposalid(::std::string* proposalid);

  // bytes ProposalMsg = 2;
  void clear_proposalmsg();
  static const int kProposalMsgFieldNumber = 2;
  const ::std::string& proposalmsg() const;
  void set_proposalmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_proposalmsg(::std::string&& value);
  #endif
  void set_proposalmsg(const char* value);
  void set_proposalmsg(const void* value, size_t size);
  ::std::string* mutable_proposalmsg();
  ::std::string* release_proposalmsg();
  void set_allocated_proposalmsg(::std::string* proposalmsg);

  // .relayer.QCSignInfos SignInfos = 5;
  bool has_signinfos() const;
  void clear_signinfos();
  static const int kSignInfosFieldNumber = 5;
  const ::relayer::QCSignInfos& signinfos() const;
  ::relayer::QCSignInfos* release_signinfos();
  ::relayer::QCSignInfos* mutable_signinfos();
  void set_allocated_signinfos(::relayer::QCSignInfos* signinfos);

  // int64 ViewNumber = 4;
  void clear_viewnumber();
  static const int kViewNumberFieldNumber = 4;
  ::google::protobuf::int64 viewnumber() const;
  void set_viewnumber(::google::protobuf::int64 value);

  // .relayer.QCState Type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::relayer::QCState type() const;
  void set_type(::relayer::QCState value);

  // @@protoc_insertion_point(class_scope:relayer.QuorumCert)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr proposalid_;
  ::google::protobuf::internal::ArenaStringPtr proposalmsg_;
  ::relayer::QCSignInfos* signinfos_;
  ::google::protobuf::int64 viewnumber_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class QCSignInfos :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.QCSignInfos) */ {
 public:
  QCSignInfos();
  virtual ~QCSignInfos();

  QCSignInfos(const QCSignInfos& from);

  inline QCSignInfos& operator=(const QCSignInfos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QCSignInfos(QCSignInfos&& from) noexcept
    : QCSignInfos() {
    *this = ::std::move(from);
  }

  inline QCSignInfos& operator=(QCSignInfos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QCSignInfos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QCSignInfos* internal_default_instance() {
    return reinterpret_cast<const QCSignInfos*>(
               &_QCSignInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(QCSignInfos* other);
  friend void swap(QCSignInfos& a, QCSignInfos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QCSignInfos* New() const final {
    return CreateMaybeMessage<QCSignInfos>(nullptr);
  }

  QCSignInfos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QCSignInfos>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QCSignInfos& from);
  void MergeFrom(const QCSignInfos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QCSignInfos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .relayer.SignInfo QCSignInfos = 1;
  int qcsigninfos_size() const;
  void clear_qcsigninfos();
  static const int kQCSignInfosFieldNumber = 1;
  ::relayer::SignInfo* mutable_qcsigninfos(int index);
  ::google::protobuf::RepeatedPtrField< ::relayer::SignInfo >*
      mutable_qcsigninfos();
  const ::relayer::SignInfo& qcsigninfos(int index) const;
  ::relayer::SignInfo* add_qcsigninfos();
  const ::google::protobuf::RepeatedPtrField< ::relayer::SignInfo >&
      qcsigninfos() const;

  // @@protoc_insertion_point(class_scope:relayer.QCSignInfos)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::relayer::SignInfo > qcsigninfos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class SignInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.SignInfo) */ {
 public:
  SignInfo();
  virtual ~SignInfo();

  SignInfo(const SignInfo& from);

  inline SignInfo& operator=(const SignInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignInfo(SignInfo&& from) noexcept
    : SignInfo() {
    *this = ::std::move(from);
  }

  inline SignInfo& operator=(SignInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SignInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignInfo* internal_default_instance() {
    return reinterpret_cast<const SignInfo*>(
               &_SignInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SignInfo* other);
  friend void swap(SignInfo& a, SignInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignInfo* New() const final {
    return CreateMaybeMessage<SignInfo>(nullptr);
  }

  SignInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SignInfo& from);
  void MergeFrom(const SignInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string PublicKey = 2;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  #if LANG_CXX11
  void set_publickey(::std::string&& value);
  #endif
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // bytes Sign = 3;
  void clear_sign();
  static const int kSignFieldNumber = 3;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const void* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // @@protoc_insertion_point(class_scope:relayer.SignInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// -------------------------------------------------------------------

class LedgerMeta :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:relayer.LedgerMeta) */ {
 public:
  LedgerMeta();
  virtual ~LedgerMeta();

  LedgerMeta(const LedgerMeta& from);

  inline LedgerMeta& operator=(const LedgerMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerMeta(LedgerMeta&& from) noexcept
    : LedgerMeta() {
    *this = ::std::move(from);
  }

  inline LedgerMeta& operator=(LedgerMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LedgerMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerMeta* internal_default_instance() {
    return reinterpret_cast<const LedgerMeta*>(
               &_LedgerMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(LedgerMeta* other);
  friend void swap(LedgerMeta& a, LedgerMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerMeta* New() const final {
    return CreateMaybeMessage<LedgerMeta>(nullptr);
  }

  LedgerMeta* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerMeta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LedgerMeta& from);
  void MergeFrom(const LedgerMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LedgerMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string root_blockid = 1;
  void clear_root_blockid();
  static const int kRootBlockidFieldNumber = 1;
  const ::std::string& root_blockid() const;
  void set_root_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_root_blockid(::std::string&& value);
  #endif
  void set_root_blockid(const char* value);
  void set_root_blockid(const char* value, size_t size);
  ::std::string* mutable_root_blockid();
  ::std::string* release_root_blockid();
  void set_allocated_root_blockid(::std::string* root_blockid);

  // string tip_blockid = 2;
  void clear_tip_blockid();
  static const int kTipBlockidFieldNumber = 2;
  const ::std::string& tip_blockid() const;
  void set_tip_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_tip_blockid(::std::string&& value);
  #endif
  void set_tip_blockid(const char* value);
  void set_tip_blockid(const char* value, size_t size);
  ::std::string* mutable_tip_blockid();
  ::std::string* release_tip_blockid();
  void set_allocated_tip_blockid(::std::string* tip_blockid);

  // int64 trunk_height = 3;
  void clear_trunk_height();
  static const int kTrunkHeightFieldNumber = 3;
  ::google::protobuf::int64 trunk_height() const;
  void set_trunk_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:relayer.LedgerMeta)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr root_blockid_;
  ::google::protobuf::internal::ArenaStringPtr tip_blockid_;
  ::google::protobuf::int64 trunk_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_relayer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InternalBlock

// int32 version = 1;
inline void InternalBlock::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 InternalBlock::version() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.version)
  return version_;
}
inline void InternalBlock::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.version)
}

// int32 nonce = 2;
inline void InternalBlock::clear_nonce() {
  nonce_ = 0;
}
inline ::google::protobuf::int32 InternalBlock::nonce() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.nonce)
  return nonce_;
}
inline void InternalBlock::set_nonce(::google::protobuf::int32 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.nonce)
}

// bytes blockid = 3;
inline void InternalBlock::clear_blockid() {
  blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::blockid() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.blockid)
  return blockid_.GetNoArena();
}
inline void InternalBlock::set_blockid(const ::std::string& value) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.blockid)
}
#if LANG_CXX11
inline void InternalBlock::set_blockid(::std::string&& value) {
  
  blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.blockid)
}
#endif
inline void InternalBlock::set_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.blockid)
}
inline void InternalBlock::set_blockid(const void* value, size_t size) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.blockid)
}
inline ::std::string* InternalBlock::mutable_blockid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.blockid)
  return blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_blockid() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.blockid)
  
  return blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_blockid(::std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockid);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.blockid)
}

// bytes pre_hash = 4;
inline void InternalBlock::clear_pre_hash() {
  pre_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::pre_hash() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.pre_hash)
  return pre_hash_.GetNoArena();
}
inline void InternalBlock::set_pre_hash(const ::std::string& value) {
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.pre_hash)
}
#if LANG_CXX11
inline void InternalBlock::set_pre_hash(::std::string&& value) {
  
  pre_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.pre_hash)
}
#endif
inline void InternalBlock::set_pre_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.pre_hash)
}
inline void InternalBlock::set_pre_hash(const void* value, size_t size) {
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.pre_hash)
}
inline ::std::string* InternalBlock::mutable_pre_hash() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.pre_hash)
  return pre_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_pre_hash() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.pre_hash)
  
  return pre_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_pre_hash(::std::string* pre_hash) {
  if (pre_hash != nullptr) {
    
  } else {
    
  }
  pre_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pre_hash);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.pre_hash)
}

// bytes proposer = 5;
inline void InternalBlock::clear_proposer() {
  proposer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::proposer() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.proposer)
  return proposer_.GetNoArena();
}
inline void InternalBlock::set_proposer(const ::std::string& value) {
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.proposer)
}
#if LANG_CXX11
inline void InternalBlock::set_proposer(::std::string&& value) {
  
  proposer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.proposer)
}
#endif
inline void InternalBlock::set_proposer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.proposer)
}
inline void InternalBlock::set_proposer(const void* value, size_t size) {
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.proposer)
}
inline ::std::string* InternalBlock::mutable_proposer() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.proposer)
  return proposer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_proposer() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.proposer)
  
  return proposer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_proposer(::std::string* proposer) {
  if (proposer != nullptr) {
    
  } else {
    
  }
  proposer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposer);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.proposer)
}

// bytes sign = 6;
inline void InternalBlock::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::sign() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.sign)
  return sign_.GetNoArena();
}
inline void InternalBlock::set_sign(const ::std::string& value) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.sign)
}
#if LANG_CXX11
inline void InternalBlock::set_sign(::std::string&& value) {
  
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.sign)
}
#endif
inline void InternalBlock::set_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.sign)
}
inline void InternalBlock::set_sign(const void* value, size_t size) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.sign)
}
inline ::std::string* InternalBlock::mutable_sign() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_sign() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.sign)
  
  return sign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_sign(::std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.sign)
}

// bytes pubkey = 7;
inline void InternalBlock::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::pubkey() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.pubkey)
  return pubkey_.GetNoArena();
}
inline void InternalBlock::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.pubkey)
}
#if LANG_CXX11
inline void InternalBlock::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.pubkey)
}
#endif
inline void InternalBlock::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.pubkey)
}
inline void InternalBlock::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.pubkey)
}
inline ::std::string* InternalBlock::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_pubkey() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != nullptr) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.pubkey)
}

// bytes merkle_root = 8;
inline void InternalBlock::clear_merkle_root() {
  merkle_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::merkle_root() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.merkle_root)
  return merkle_root_.GetNoArena();
}
inline void InternalBlock::set_merkle_root(const ::std::string& value) {
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.merkle_root)
}
#if LANG_CXX11
inline void InternalBlock::set_merkle_root(::std::string&& value) {
  
  merkle_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.merkle_root)
}
#endif
inline void InternalBlock::set_merkle_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.merkle_root)
}
inline void InternalBlock::set_merkle_root(const void* value, size_t size) {
  
  merkle_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.merkle_root)
}
inline ::std::string* InternalBlock::mutable_merkle_root() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.merkle_root)
  return merkle_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_merkle_root() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.merkle_root)
  
  return merkle_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_merkle_root(::std::string* merkle_root) {
  if (merkle_root != nullptr) {
    
  } else {
    
  }
  merkle_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), merkle_root);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.merkle_root)
}

// int64 height = 9;
inline void InternalBlock::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 InternalBlock::height() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.height)
  return height_;
}
inline void InternalBlock::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.height)
}

// int64 timestamp = 10;
inline void InternalBlock::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 InternalBlock::timestamp() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.timestamp)
  return timestamp_;
}
inline void InternalBlock::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.timestamp)
}

// repeated .relayer.Transaction transactions = 11;
inline int InternalBlock::transactions_size() const {
  return transactions_.size();
}
inline void InternalBlock::clear_transactions() {
  transactions_.Clear();
}
inline ::relayer::Transaction* InternalBlock::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.transactions)
  return transactions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::Transaction >*
InternalBlock::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:relayer.InternalBlock.transactions)
  return &transactions_;
}
inline const ::relayer::Transaction& InternalBlock::transactions(int index) const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.transactions)
  return transactions_.Get(index);
}
inline ::relayer::Transaction* InternalBlock::add_transactions() {
  // @@protoc_insertion_point(field_add:relayer.InternalBlock.transactions)
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::Transaction >&
InternalBlock::transactions() const {
  // @@protoc_insertion_point(field_list:relayer.InternalBlock.transactions)
  return transactions_;
}

// int32 tx_count = 12;
inline void InternalBlock::clear_tx_count() {
  tx_count_ = 0;
}
inline ::google::protobuf::int32 InternalBlock::tx_count() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.tx_count)
  return tx_count_;
}
inline void InternalBlock::set_tx_count(::google::protobuf::int32 value) {
  
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.tx_count)
}

// repeated bytes merkle_tree = 13;
inline int InternalBlock::merkle_tree_size() const {
  return merkle_tree_.size();
}
inline void InternalBlock::clear_merkle_tree() {
  merkle_tree_.Clear();
}
inline const ::std::string& InternalBlock::merkle_tree(int index) const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.merkle_tree)
  return merkle_tree_.Get(index);
}
inline ::std::string* InternalBlock::mutable_merkle_tree(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.merkle_tree)
  return merkle_tree_.Mutable(index);
}
inline void InternalBlock::set_merkle_tree(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.merkle_tree)
  merkle_tree_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void InternalBlock::set_merkle_tree(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.merkle_tree)
  merkle_tree_.Mutable(index)->assign(std::move(value));
}
#endif
inline void InternalBlock::set_merkle_tree(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  merkle_tree_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.merkle_tree)
}
inline void InternalBlock::set_merkle_tree(int index, const void* value, size_t size) {
  merkle_tree_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.merkle_tree)
}
inline ::std::string* InternalBlock::add_merkle_tree() {
  // @@protoc_insertion_point(field_add_mutable:relayer.InternalBlock.merkle_tree)
  return merkle_tree_.Add();
}
inline void InternalBlock::add_merkle_tree(const ::std::string& value) {
  merkle_tree_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:relayer.InternalBlock.merkle_tree)
}
#if LANG_CXX11
inline void InternalBlock::add_merkle_tree(::std::string&& value) {
  merkle_tree_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:relayer.InternalBlock.merkle_tree)
}
#endif
inline void InternalBlock::add_merkle_tree(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  merkle_tree_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:relayer.InternalBlock.merkle_tree)
}
inline void InternalBlock::add_merkle_tree(const void* value, size_t size) {
  merkle_tree_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:relayer.InternalBlock.merkle_tree)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
InternalBlock::merkle_tree() const {
  // @@protoc_insertion_point(field_list:relayer.InternalBlock.merkle_tree)
  return merkle_tree_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
InternalBlock::mutable_merkle_tree() {
  // @@protoc_insertion_point(field_mutable_list:relayer.InternalBlock.merkle_tree)
  return &merkle_tree_;
}

// int64 curTerm = 16;
inline void InternalBlock::clear_curterm() {
  curterm_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 InternalBlock::curterm() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.curTerm)
  return curterm_;
}
inline void InternalBlock::set_curterm(::google::protobuf::int64 value) {
  
  curterm_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.curTerm)
}

// int64 curBlockNum = 17;
inline void InternalBlock::clear_curblocknum() {
  curblocknum_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 InternalBlock::curblocknum() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.curBlockNum)
  return curblocknum_;
}
inline void InternalBlock::set_curblocknum(::google::protobuf::int64 value) {
  
  curblocknum_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.curBlockNum)
}

// map<string, string> failed_txs = 18;
inline int InternalBlock::failed_txs_size() const {
  return failed_txs_.size();
}
inline void InternalBlock::clear_failed_txs() {
  failed_txs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
InternalBlock::failed_txs() const {
  // @@protoc_insertion_point(field_map:relayer.InternalBlock.failed_txs)
  return failed_txs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
InternalBlock::mutable_failed_txs() {
  // @@protoc_insertion_point(field_mutable_map:relayer.InternalBlock.failed_txs)
  return failed_txs_.MutableMap();
}

// int32 targetBits = 19;
inline void InternalBlock::clear_targetbits() {
  targetbits_ = 0;
}
inline ::google::protobuf::int32 InternalBlock::targetbits() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.targetBits)
  return targetbits_;
}
inline void InternalBlock::set_targetbits(::google::protobuf::int32 value) {
  
  targetbits_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.targetBits)
}

// .relayer.QuorumCert Justify = 20;
inline bool InternalBlock::has_justify() const {
  return this != internal_default_instance() && justify_ != nullptr;
}
inline void InternalBlock::clear_justify() {
  if (GetArenaNoVirtual() == nullptr && justify_ != nullptr) {
    delete justify_;
  }
  justify_ = nullptr;
}
inline const ::relayer::QuorumCert& InternalBlock::justify() const {
  const ::relayer::QuorumCert* p = justify_;
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.Justify)
  return p != nullptr ? *p : *reinterpret_cast<const ::relayer::QuorumCert*>(
      &::relayer::_QuorumCert_default_instance_);
}
inline ::relayer::QuorumCert* InternalBlock::release_justify() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.Justify)
  
  ::relayer::QuorumCert* temp = justify_;
  justify_ = nullptr;
  return temp;
}
inline ::relayer::QuorumCert* InternalBlock::mutable_justify() {
  
  if (justify_ == nullptr) {
    auto* p = CreateMaybeMessage<::relayer::QuorumCert>(GetArenaNoVirtual());
    justify_ = p;
  }
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.Justify)
  return justify_;
}
inline void InternalBlock::set_allocated_justify(::relayer::QuorumCert* justify) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete justify_;
  }
  if (justify) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      justify = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, justify, submessage_arena);
    }
    
  } else {
    
  }
  justify_ = justify;
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.Justify)
}

// bool in_trunk = 14;
inline void InternalBlock::clear_in_trunk() {
  in_trunk_ = false;
}
inline bool InternalBlock::in_trunk() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.in_trunk)
  return in_trunk_;
}
inline void InternalBlock::set_in_trunk(bool value) {
  
  in_trunk_ = value;
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.in_trunk)
}

// bytes next_hash = 15;
inline void InternalBlock::clear_next_hash() {
  next_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InternalBlock::next_hash() const {
  // @@protoc_insertion_point(field_get:relayer.InternalBlock.next_hash)
  return next_hash_.GetNoArena();
}
inline void InternalBlock::set_next_hash(const ::std::string& value) {
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InternalBlock.next_hash)
}
#if LANG_CXX11
inline void InternalBlock::set_next_hash(::std::string&& value) {
  
  next_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InternalBlock.next_hash)
}
#endif
inline void InternalBlock::set_next_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InternalBlock.next_hash)
}
inline void InternalBlock::set_next_hash(const void* value, size_t size) {
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InternalBlock.next_hash)
}
inline ::std::string* InternalBlock::mutable_next_hash() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InternalBlock.next_hash)
  return next_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalBlock::release_next_hash() {
  // @@protoc_insertion_point(field_release:relayer.InternalBlock.next_hash)
  
  return next_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalBlock::set_allocated_next_hash(::std::string* next_hash) {
  if (next_hash != nullptr) {
    
  } else {
    
  }
  next_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_hash);
  // @@protoc_insertion_point(field_set_allocated:relayer.InternalBlock.next_hash)
}

// -------------------------------------------------------------------

// Transaction

// bytes txid = 1;
inline void Transaction::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::txid() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.txid)
  return txid_.GetNoArena();
}
inline void Transaction::set_txid(const ::std::string& value) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.Transaction.txid)
}
#if LANG_CXX11
inline void Transaction::set_txid(::std::string&& value) {
  
  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.Transaction.txid)
}
#endif
inline void Transaction::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.txid)
}
inline void Transaction::set_txid(const void* value, size_t size) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.txid)
}
inline ::std::string* Transaction::mutable_txid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.txid)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_txid() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.txid)
  
  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_txid(::std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.txid)
}

// bytes blockid = 2;
inline void Transaction::clear_blockid() {
  blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::blockid() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.blockid)
  return blockid_.GetNoArena();
}
inline void Transaction::set_blockid(const ::std::string& value) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.Transaction.blockid)
}
#if LANG_CXX11
inline void Transaction::set_blockid(::std::string&& value) {
  
  blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.Transaction.blockid)
}
#endif
inline void Transaction::set_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.blockid)
}
inline void Transaction::set_blockid(const void* value, size_t size) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.blockid)
}
inline ::std::string* Transaction::mutable_blockid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.blockid)
  return blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_blockid() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.blockid)
  
  return blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_blockid(::std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockid);
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.blockid)
}

// repeated .relayer.TxInput tx_inputs = 3;
inline int Transaction::tx_inputs_size() const {
  return tx_inputs_.size();
}
inline void Transaction::clear_tx_inputs() {
  tx_inputs_.Clear();
}
inline ::relayer::TxInput* Transaction::mutable_tx_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.tx_inputs)
  return tx_inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::TxInput >*
Transaction::mutable_tx_inputs() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.tx_inputs)
  return &tx_inputs_;
}
inline const ::relayer::TxInput& Transaction::tx_inputs(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.tx_inputs)
  return tx_inputs_.Get(index);
}
inline ::relayer::TxInput* Transaction::add_tx_inputs() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.tx_inputs)
  return tx_inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::TxInput >&
Transaction::tx_inputs() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.tx_inputs)
  return tx_inputs_;
}

// repeated .relayer.TxOutput tx_outputs = 4;
inline int Transaction::tx_outputs_size() const {
  return tx_outputs_.size();
}
inline void Transaction::clear_tx_outputs() {
  tx_outputs_.Clear();
}
inline ::relayer::TxOutput* Transaction::mutable_tx_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.tx_outputs)
  return tx_outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::TxOutput >*
Transaction::mutable_tx_outputs() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.tx_outputs)
  return &tx_outputs_;
}
inline const ::relayer::TxOutput& Transaction::tx_outputs(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.tx_outputs)
  return tx_outputs_.Get(index);
}
inline ::relayer::TxOutput* Transaction::add_tx_outputs() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.tx_outputs)
  return tx_outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::TxOutput >&
Transaction::tx_outputs() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.tx_outputs)
  return tx_outputs_;
}

// bytes desc = 6;
inline void Transaction::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::desc() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.desc)
  return desc_.GetNoArena();
}
inline void Transaction::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.Transaction.desc)
}
#if LANG_CXX11
inline void Transaction::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.Transaction.desc)
}
#endif
inline void Transaction::set_desc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.desc)
}
inline void Transaction::set_desc(const void* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.desc)
}
inline ::std::string* Transaction::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_desc() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_desc(::std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.desc)
}

// bool coinbase = 7;
inline void Transaction::clear_coinbase() {
  coinbase_ = false;
}
inline bool Transaction::coinbase() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.coinbase)
  return coinbase_;
}
inline void Transaction::set_coinbase(bool value) {
  
  coinbase_ = value;
  // @@protoc_insertion_point(field_set:relayer.Transaction.coinbase)
}

// string nonce = 8;
inline void Transaction::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::nonce() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.nonce)
  return nonce_.GetNoArena();
}
inline void Transaction::set_nonce(const ::std::string& value) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.Transaction.nonce)
}
#if LANG_CXX11
inline void Transaction::set_nonce(::std::string&& value) {
  
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.Transaction.nonce)
}
#endif
inline void Transaction::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.nonce)
}
inline void Transaction::set_nonce(const char* value, size_t size) {
  
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.nonce)
}
inline ::std::string* Transaction::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_nonce() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.nonce)
  
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_nonce(::std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.nonce)
}

// int64 timestamp = 9;
inline void Transaction::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.timestamp)
  return timestamp_;
}
inline void Transaction::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:relayer.Transaction.timestamp)
}

// int32 version = 10;
inline void Transaction::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Transaction::version() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.version)
  return version_;
}
inline void Transaction::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:relayer.Transaction.version)
}

// bool autogen = 11;
inline void Transaction::clear_autogen() {
  autogen_ = false;
}
inline bool Transaction::autogen() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.autogen)
  return autogen_;
}
inline void Transaction::set_autogen(bool value) {
  
  autogen_ = value;
  // @@protoc_insertion_point(field_set:relayer.Transaction.autogen)
}

// repeated .relayer.TxInputExt tx_inputs_ext = 23;
inline int Transaction::tx_inputs_ext_size() const {
  return tx_inputs_ext_.size();
}
inline void Transaction::clear_tx_inputs_ext() {
  tx_inputs_ext_.Clear();
}
inline ::relayer::TxInputExt* Transaction::mutable_tx_inputs_ext(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.tx_inputs_ext)
  return tx_inputs_ext_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::TxInputExt >*
Transaction::mutable_tx_inputs_ext() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.tx_inputs_ext)
  return &tx_inputs_ext_;
}
inline const ::relayer::TxInputExt& Transaction::tx_inputs_ext(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.tx_inputs_ext)
  return tx_inputs_ext_.Get(index);
}
inline ::relayer::TxInputExt* Transaction::add_tx_inputs_ext() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.tx_inputs_ext)
  return tx_inputs_ext_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::TxInputExt >&
Transaction::tx_inputs_ext() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.tx_inputs_ext)
  return tx_inputs_ext_;
}

// repeated .relayer.TxOutputExt tx_outputs_ext = 24;
inline int Transaction::tx_outputs_ext_size() const {
  return tx_outputs_ext_.size();
}
inline void Transaction::clear_tx_outputs_ext() {
  tx_outputs_ext_.Clear();
}
inline ::relayer::TxOutputExt* Transaction::mutable_tx_outputs_ext(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.tx_outputs_ext)
  return tx_outputs_ext_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::TxOutputExt >*
Transaction::mutable_tx_outputs_ext() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.tx_outputs_ext)
  return &tx_outputs_ext_;
}
inline const ::relayer::TxOutputExt& Transaction::tx_outputs_ext(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.tx_outputs_ext)
  return tx_outputs_ext_.Get(index);
}
inline ::relayer::TxOutputExt* Transaction::add_tx_outputs_ext() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.tx_outputs_ext)
  return tx_outputs_ext_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::TxOutputExt >&
Transaction::tx_outputs_ext() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.tx_outputs_ext)
  return tx_outputs_ext_;
}

// repeated .relayer.InvokeRequest contract_requests = 25;
inline int Transaction::contract_requests_size() const {
  return contract_requests_.size();
}
inline void Transaction::clear_contract_requests() {
  contract_requests_.Clear();
}
inline ::relayer::InvokeRequest* Transaction::mutable_contract_requests(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.contract_requests)
  return contract_requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::InvokeRequest >*
Transaction::mutable_contract_requests() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.contract_requests)
  return &contract_requests_;
}
inline const ::relayer::InvokeRequest& Transaction::contract_requests(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.contract_requests)
  return contract_requests_.Get(index);
}
inline ::relayer::InvokeRequest* Transaction::add_contract_requests() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.contract_requests)
  return contract_requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::InvokeRequest >&
Transaction::contract_requests() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.contract_requests)
  return contract_requests_;
}

// string initiator = 26;
inline void Transaction::clear_initiator() {
  initiator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::initiator() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.initiator)
  return initiator_.GetNoArena();
}
inline void Transaction::set_initiator(const ::std::string& value) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.Transaction.initiator)
}
#if LANG_CXX11
inline void Transaction::set_initiator(::std::string&& value) {
  
  initiator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.Transaction.initiator)
}
#endif
inline void Transaction::set_initiator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.initiator)
}
inline void Transaction::set_initiator(const char* value, size_t size) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.initiator)
}
inline ::std::string* Transaction::mutable_initiator() {
  
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.initiator)
  return initiator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_initiator() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.initiator)
  
  return initiator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_initiator(::std::string* initiator) {
  if (initiator != nullptr) {
    
  } else {
    
  }
  initiator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), initiator);
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.initiator)
}

// repeated string auth_require = 27;
inline int Transaction::auth_require_size() const {
  return auth_require_.size();
}
inline void Transaction::clear_auth_require() {
  auth_require_.Clear();
}
inline const ::std::string& Transaction::auth_require(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.auth_require)
  return auth_require_.Get(index);
}
inline ::std::string* Transaction::mutable_auth_require(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.auth_require)
  return auth_require_.Mutable(index);
}
inline void Transaction::set_auth_require(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:relayer.Transaction.auth_require)
  auth_require_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Transaction::set_auth_require(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:relayer.Transaction.auth_require)
  auth_require_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Transaction::set_auth_require(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:relayer.Transaction.auth_require)
}
inline void Transaction::set_auth_require(int index, const char* value, size_t size) {
  auth_require_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:relayer.Transaction.auth_require)
}
inline ::std::string* Transaction::add_auth_require() {
  // @@protoc_insertion_point(field_add_mutable:relayer.Transaction.auth_require)
  return auth_require_.Add();
}
inline void Transaction::add_auth_require(const ::std::string& value) {
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:relayer.Transaction.auth_require)
}
#if LANG_CXX11
inline void Transaction::add_auth_require(::std::string&& value) {
  auth_require_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:relayer.Transaction.auth_require)
}
#endif
inline void Transaction::add_auth_require(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:relayer.Transaction.auth_require)
}
inline void Transaction::add_auth_require(const char* value, size_t size) {
  auth_require_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:relayer.Transaction.auth_require)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Transaction::auth_require() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.auth_require)
  return auth_require_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Transaction::mutable_auth_require() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.auth_require)
  return &auth_require_;
}

// repeated .relayer.SignatureInfo initiator_signs = 28;
inline int Transaction::initiator_signs_size() const {
  return initiator_signs_.size();
}
inline void Transaction::clear_initiator_signs() {
  initiator_signs_.Clear();
}
inline ::relayer::SignatureInfo* Transaction::mutable_initiator_signs(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.initiator_signs)
  return initiator_signs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >*
Transaction::mutable_initiator_signs() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.initiator_signs)
  return &initiator_signs_;
}
inline const ::relayer::SignatureInfo& Transaction::initiator_signs(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.initiator_signs)
  return initiator_signs_.Get(index);
}
inline ::relayer::SignatureInfo* Transaction::add_initiator_signs() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.initiator_signs)
  return initiator_signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >&
Transaction::initiator_signs() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.initiator_signs)
  return initiator_signs_;
}

// repeated .relayer.SignatureInfo auth_require_signs = 29;
inline int Transaction::auth_require_signs_size() const {
  return auth_require_signs_.size();
}
inline void Transaction::clear_auth_require_signs() {
  auth_require_signs_.Clear();
}
inline ::relayer::SignatureInfo* Transaction::mutable_auth_require_signs(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.auth_require_signs)
  return auth_require_signs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >*
Transaction::mutable_auth_require_signs() {
  // @@protoc_insertion_point(field_mutable_list:relayer.Transaction.auth_require_signs)
  return &auth_require_signs_;
}
inline const ::relayer::SignatureInfo& Transaction::auth_require_signs(int index) const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.auth_require_signs)
  return auth_require_signs_.Get(index);
}
inline ::relayer::SignatureInfo* Transaction::add_auth_require_signs() {
  // @@protoc_insertion_point(field_add:relayer.Transaction.auth_require_signs)
  return auth_require_signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::SignatureInfo >&
Transaction::auth_require_signs() const {
  // @@protoc_insertion_point(field_list:relayer.Transaction.auth_require_signs)
  return auth_require_signs_;
}

// int64 received_timestamp = 30;
inline void Transaction::clear_received_timestamp() {
  received_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::received_timestamp() const {
  // @@protoc_insertion_point(field_get:relayer.Transaction.received_timestamp)
  return received_timestamp_;
}
inline void Transaction::set_received_timestamp(::google::protobuf::int64 value) {
  
  received_timestamp_ = value;
  // @@protoc_insertion_point(field_set:relayer.Transaction.received_timestamp)
}

// .relayer.XuperSignature xuper_sign = 31;
inline bool Transaction::has_xuper_sign() const {
  return this != internal_default_instance() && xuper_sign_ != nullptr;
}
inline void Transaction::clear_xuper_sign() {
  if (GetArenaNoVirtual() == nullptr && xuper_sign_ != nullptr) {
    delete xuper_sign_;
  }
  xuper_sign_ = nullptr;
}
inline const ::relayer::XuperSignature& Transaction::xuper_sign() const {
  const ::relayer::XuperSignature* p = xuper_sign_;
  // @@protoc_insertion_point(field_get:relayer.Transaction.xuper_sign)
  return p != nullptr ? *p : *reinterpret_cast<const ::relayer::XuperSignature*>(
      &::relayer::_XuperSignature_default_instance_);
}
inline ::relayer::XuperSignature* Transaction::release_xuper_sign() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.xuper_sign)
  
  ::relayer::XuperSignature* temp = xuper_sign_;
  xuper_sign_ = nullptr;
  return temp;
}
inline ::relayer::XuperSignature* Transaction::mutable_xuper_sign() {
  
  if (xuper_sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::relayer::XuperSignature>(GetArenaNoVirtual());
    xuper_sign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.xuper_sign)
  return xuper_sign_;
}
inline void Transaction::set_allocated_xuper_sign(::relayer::XuperSignature* xuper_sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete xuper_sign_;
  }
  if (xuper_sign) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      xuper_sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xuper_sign, submessage_arena);
    }
    
  } else {
    
  }
  xuper_sign_ = xuper_sign;
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.xuper_sign)
}

// .relayer.ModifyBlock modify_block = 32;
inline bool Transaction::has_modify_block() const {
  return this != internal_default_instance() && modify_block_ != nullptr;
}
inline void Transaction::clear_modify_block() {
  if (GetArenaNoVirtual() == nullptr && modify_block_ != nullptr) {
    delete modify_block_;
  }
  modify_block_ = nullptr;
}
inline const ::relayer::ModifyBlock& Transaction::modify_block() const {
  const ::relayer::ModifyBlock* p = modify_block_;
  // @@protoc_insertion_point(field_get:relayer.Transaction.modify_block)
  return p != nullptr ? *p : *reinterpret_cast<const ::relayer::ModifyBlock*>(
      &::relayer::_ModifyBlock_default_instance_);
}
inline ::relayer::ModifyBlock* Transaction::release_modify_block() {
  // @@protoc_insertion_point(field_release:relayer.Transaction.modify_block)
  
  ::relayer::ModifyBlock* temp = modify_block_;
  modify_block_ = nullptr;
  return temp;
}
inline ::relayer::ModifyBlock* Transaction::mutable_modify_block() {
  
  if (modify_block_ == nullptr) {
    auto* p = CreateMaybeMessage<::relayer::ModifyBlock>(GetArenaNoVirtual());
    modify_block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:relayer.Transaction.modify_block)
  return modify_block_;
}
inline void Transaction::set_allocated_modify_block(::relayer::ModifyBlock* modify_block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete modify_block_;
  }
  if (modify_block) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      modify_block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, modify_block, submessage_arena);
    }
    
  } else {
    
  }
  modify_block_ = modify_block;
  // @@protoc_insertion_point(field_set_allocated:relayer.Transaction.modify_block)
}

// -------------------------------------------------------------------

// TxInput

// bytes ref_txid = 1;
inline void TxInput::clear_ref_txid() {
  ref_txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::ref_txid() const {
  // @@protoc_insertion_point(field_get:relayer.TxInput.ref_txid)
  return ref_txid_.GetNoArena();
}
inline void TxInput::set_ref_txid(const ::std::string& value) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInput.ref_txid)
}
#if LANG_CXX11
inline void TxInput::set_ref_txid(::std::string&& value) {
  
  ref_txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInput.ref_txid)
}
#endif
inline void TxInput::set_ref_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInput.ref_txid)
}
inline void TxInput::set_ref_txid(const void* value, size_t size) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInput.ref_txid)
}
inline ::std::string* TxInput::mutable_ref_txid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInput.ref_txid)
  return ref_txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_ref_txid() {
  // @@protoc_insertion_point(field_release:relayer.TxInput.ref_txid)
  
  return ref_txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_ref_txid(::std::string* ref_txid) {
  if (ref_txid != nullptr) {
    
  } else {
    
  }
  ref_txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_txid);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInput.ref_txid)
}

// int32 ref_offset = 2;
inline void TxInput::clear_ref_offset() {
  ref_offset_ = 0;
}
inline ::google::protobuf::int32 TxInput::ref_offset() const {
  // @@protoc_insertion_point(field_get:relayer.TxInput.ref_offset)
  return ref_offset_;
}
inline void TxInput::set_ref_offset(::google::protobuf::int32 value) {
  
  ref_offset_ = value;
  // @@protoc_insertion_point(field_set:relayer.TxInput.ref_offset)
}

// bytes from_addr = 5;
inline void TxInput::clear_from_addr() {
  from_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::from_addr() const {
  // @@protoc_insertion_point(field_get:relayer.TxInput.from_addr)
  return from_addr_.GetNoArena();
}
inline void TxInput::set_from_addr(const ::std::string& value) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInput.from_addr)
}
#if LANG_CXX11
inline void TxInput::set_from_addr(::std::string&& value) {
  
  from_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInput.from_addr)
}
#endif
inline void TxInput::set_from_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInput.from_addr)
}
inline void TxInput::set_from_addr(const void* value, size_t size) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInput.from_addr)
}
inline ::std::string* TxInput::mutable_from_addr() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInput.from_addr)
  return from_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_from_addr() {
  // @@protoc_insertion_point(field_release:relayer.TxInput.from_addr)
  
  return from_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_from_addr(::std::string* from_addr) {
  if (from_addr != nullptr) {
    
  } else {
    
  }
  from_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_addr);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInput.from_addr)
}

// bytes amount = 6;
inline void TxInput::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::amount() const {
  // @@protoc_insertion_point(field_get:relayer.TxInput.amount)
  return amount_.GetNoArena();
}
inline void TxInput::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInput.amount)
}
#if LANG_CXX11
inline void TxInput::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInput.amount)
}
#endif
inline void TxInput::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInput.amount)
}
inline void TxInput::set_amount(const void* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInput.amount)
}
inline ::std::string* TxInput::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInput.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_amount() {
  // @@protoc_insertion_point(field_release:relayer.TxInput.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInput.amount)
}

// int64 frozen_height = 7;
inline void TxInput::clear_frozen_height() {
  frozen_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TxInput::frozen_height() const {
  // @@protoc_insertion_point(field_get:relayer.TxInput.frozen_height)
  return frozen_height_;
}
inline void TxInput::set_frozen_height(::google::protobuf::int64 value) {
  
  frozen_height_ = value;
  // @@protoc_insertion_point(field_set:relayer.TxInput.frozen_height)
}

// -------------------------------------------------------------------

// TxOutput

// bytes amount = 1;
inline void TxOutput::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutput::amount() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutput.amount)
  return amount_.GetNoArena();
}
inline void TxOutput::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxOutput.amount)
}
#if LANG_CXX11
inline void TxOutput::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxOutput.amount)
}
#endif
inline void TxOutput::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxOutput.amount)
}
inline void TxOutput::set_amount(const void* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxOutput.amount)
}
inline ::std::string* TxOutput::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxOutput.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutput::release_amount() {
  // @@protoc_insertion_point(field_release:relayer.TxOutput.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutput::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxOutput.amount)
}

// bytes to_addr = 2;
inline void TxOutput::clear_to_addr() {
  to_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutput::to_addr() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutput.to_addr)
  return to_addr_.GetNoArena();
}
inline void TxOutput::set_to_addr(const ::std::string& value) {
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxOutput.to_addr)
}
#if LANG_CXX11
inline void TxOutput::set_to_addr(::std::string&& value) {
  
  to_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxOutput.to_addr)
}
#endif
inline void TxOutput::set_to_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxOutput.to_addr)
}
inline void TxOutput::set_to_addr(const void* value, size_t size) {
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxOutput.to_addr)
}
inline ::std::string* TxOutput::mutable_to_addr() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxOutput.to_addr)
  return to_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutput::release_to_addr() {
  // @@protoc_insertion_point(field_release:relayer.TxOutput.to_addr)
  
  return to_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutput::set_allocated_to_addr(::std::string* to_addr) {
  if (to_addr != nullptr) {
    
  } else {
    
  }
  to_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_addr);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxOutput.to_addr)
}

// int64 frozen_height = 4;
inline void TxOutput::clear_frozen_height() {
  frozen_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TxOutput::frozen_height() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutput.frozen_height)
  return frozen_height_;
}
inline void TxOutput::set_frozen_height(::google::protobuf::int64 value) {
  
  frozen_height_ = value;
  // @@protoc_insertion_point(field_set:relayer.TxOutput.frozen_height)
}

// -------------------------------------------------------------------

// TxInputExt

// string bucket = 1;
inline void TxInputExt::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInputExt::bucket() const {
  // @@protoc_insertion_point(field_get:relayer.TxInputExt.bucket)
  return bucket_.GetNoArena();
}
inline void TxInputExt::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInputExt.bucket)
}
#if LANG_CXX11
inline void TxInputExt::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInputExt.bucket)
}
#endif
inline void TxInputExt::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInputExt.bucket)
}
inline void TxInputExt::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInputExt.bucket)
}
inline ::std::string* TxInputExt::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInputExt.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInputExt::release_bucket() {
  // @@protoc_insertion_point(field_release:relayer.TxInputExt.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInputExt::set_allocated_bucket(::std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInputExt.bucket)
}

// bytes key = 2;
inline void TxInputExt::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInputExt::key() const {
  // @@protoc_insertion_point(field_get:relayer.TxInputExt.key)
  return key_.GetNoArena();
}
inline void TxInputExt::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInputExt.key)
}
#if LANG_CXX11
inline void TxInputExt::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInputExt.key)
}
#endif
inline void TxInputExt::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInputExt.key)
}
inline void TxInputExt::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInputExt.key)
}
inline ::std::string* TxInputExt::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInputExt.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInputExt::release_key() {
  // @@protoc_insertion_point(field_release:relayer.TxInputExt.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInputExt::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInputExt.key)
}

// bytes ref_txid = 3;
inline void TxInputExt::clear_ref_txid() {
  ref_txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInputExt::ref_txid() const {
  // @@protoc_insertion_point(field_get:relayer.TxInputExt.ref_txid)
  return ref_txid_.GetNoArena();
}
inline void TxInputExt::set_ref_txid(const ::std::string& value) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxInputExt.ref_txid)
}
#if LANG_CXX11
inline void TxInputExt::set_ref_txid(::std::string&& value) {
  
  ref_txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxInputExt.ref_txid)
}
#endif
inline void TxInputExt::set_ref_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxInputExt.ref_txid)
}
inline void TxInputExt::set_ref_txid(const void* value, size_t size) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxInputExt.ref_txid)
}
inline ::std::string* TxInputExt::mutable_ref_txid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxInputExt.ref_txid)
  return ref_txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInputExt::release_ref_txid() {
  // @@protoc_insertion_point(field_release:relayer.TxInputExt.ref_txid)
  
  return ref_txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInputExt::set_allocated_ref_txid(::std::string* ref_txid) {
  if (ref_txid != nullptr) {
    
  } else {
    
  }
  ref_txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_txid);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxInputExt.ref_txid)
}

// int32 ref_offset = 4;
inline void TxInputExt::clear_ref_offset() {
  ref_offset_ = 0;
}
inline ::google::protobuf::int32 TxInputExt::ref_offset() const {
  // @@protoc_insertion_point(field_get:relayer.TxInputExt.ref_offset)
  return ref_offset_;
}
inline void TxInputExt::set_ref_offset(::google::protobuf::int32 value) {
  
  ref_offset_ = value;
  // @@protoc_insertion_point(field_set:relayer.TxInputExt.ref_offset)
}

// -------------------------------------------------------------------

// TxOutputExt

// string bucket = 1;
inline void TxOutputExt::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutputExt::bucket() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutputExt.bucket)
  return bucket_.GetNoArena();
}
inline void TxOutputExt::set_bucket(const ::std::string& value) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxOutputExt.bucket)
}
#if LANG_CXX11
inline void TxOutputExt::set_bucket(::std::string&& value) {
  
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxOutputExt.bucket)
}
#endif
inline void TxOutputExt::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxOutputExt.bucket)
}
inline void TxOutputExt::set_bucket(const char* value, size_t size) {
  
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxOutputExt.bucket)
}
inline ::std::string* TxOutputExt::mutable_bucket() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxOutputExt.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputExt::release_bucket() {
  // @@protoc_insertion_point(field_release:relayer.TxOutputExt.bucket)
  
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputExt::set_allocated_bucket(::std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxOutputExt.bucket)
}

// bytes key = 2;
inline void TxOutputExt::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutputExt::key() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutputExt.key)
  return key_.GetNoArena();
}
inline void TxOutputExt::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxOutputExt.key)
}
#if LANG_CXX11
inline void TxOutputExt::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxOutputExt.key)
}
#endif
inline void TxOutputExt::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxOutputExt.key)
}
inline void TxOutputExt::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxOutputExt.key)
}
inline ::std::string* TxOutputExt::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxOutputExt.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputExt::release_key() {
  // @@protoc_insertion_point(field_release:relayer.TxOutputExt.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputExt::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxOutputExt.key)
}

// bytes value = 3;
inline void TxOutputExt::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutputExt::value() const {
  // @@protoc_insertion_point(field_get:relayer.TxOutputExt.value)
  return value_.GetNoArena();
}
inline void TxOutputExt::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.TxOutputExt.value)
}
#if LANG_CXX11
inline void TxOutputExt::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.TxOutputExt.value)
}
#endif
inline void TxOutputExt::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.TxOutputExt.value)
}
inline void TxOutputExt::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.TxOutputExt.value)
}
inline ::std::string* TxOutputExt::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:relayer.TxOutputExt.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputExt::release_value() {
  // @@protoc_insertion_point(field_release:relayer.TxOutputExt.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputExt::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:relayer.TxOutputExt.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InvokeRequest

// string module_name = 1;
inline void InvokeRequest::clear_module_name() {
  module_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvokeRequest::module_name() const {
  // @@protoc_insertion_point(field_get:relayer.InvokeRequest.module_name)
  return module_name_.GetNoArena();
}
inline void InvokeRequest::set_module_name(const ::std::string& value) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InvokeRequest.module_name)
}
#if LANG_CXX11
inline void InvokeRequest::set_module_name(::std::string&& value) {
  
  module_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InvokeRequest.module_name)
}
#endif
inline void InvokeRequest::set_module_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InvokeRequest.module_name)
}
inline void InvokeRequest::set_module_name(const char* value, size_t size) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InvokeRequest.module_name)
}
inline ::std::string* InvokeRequest::mutable_module_name() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InvokeRequest.module_name)
  return module_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvokeRequest::release_module_name() {
  // @@protoc_insertion_point(field_release:relayer.InvokeRequest.module_name)
  
  return module_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvokeRequest::set_allocated_module_name(::std::string* module_name) {
  if (module_name != nullptr) {
    
  } else {
    
  }
  module_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_name);
  // @@protoc_insertion_point(field_set_allocated:relayer.InvokeRequest.module_name)
}

// string contract_name = 2;
inline void InvokeRequest::clear_contract_name() {
  contract_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvokeRequest::contract_name() const {
  // @@protoc_insertion_point(field_get:relayer.InvokeRequest.contract_name)
  return contract_name_.GetNoArena();
}
inline void InvokeRequest::set_contract_name(const ::std::string& value) {
  
  contract_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InvokeRequest.contract_name)
}
#if LANG_CXX11
inline void InvokeRequest::set_contract_name(::std::string&& value) {
  
  contract_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InvokeRequest.contract_name)
}
#endif
inline void InvokeRequest::set_contract_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InvokeRequest.contract_name)
}
inline void InvokeRequest::set_contract_name(const char* value, size_t size) {
  
  contract_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InvokeRequest.contract_name)
}
inline ::std::string* InvokeRequest::mutable_contract_name() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InvokeRequest.contract_name)
  return contract_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvokeRequest::release_contract_name() {
  // @@protoc_insertion_point(field_release:relayer.InvokeRequest.contract_name)
  
  return contract_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvokeRequest::set_allocated_contract_name(::std::string* contract_name) {
  if (contract_name != nullptr) {
    
  } else {
    
  }
  contract_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_name);
  // @@protoc_insertion_point(field_set_allocated:relayer.InvokeRequest.contract_name)
}

// string method_name = 3;
inline void InvokeRequest::clear_method_name() {
  method_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvokeRequest::method_name() const {
  // @@protoc_insertion_point(field_get:relayer.InvokeRequest.method_name)
  return method_name_.GetNoArena();
}
inline void InvokeRequest::set_method_name(const ::std::string& value) {
  
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InvokeRequest.method_name)
}
#if LANG_CXX11
inline void InvokeRequest::set_method_name(::std::string&& value) {
  
  method_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InvokeRequest.method_name)
}
#endif
inline void InvokeRequest::set_method_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InvokeRequest.method_name)
}
inline void InvokeRequest::set_method_name(const char* value, size_t size) {
  
  method_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InvokeRequest.method_name)
}
inline ::std::string* InvokeRequest::mutable_method_name() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InvokeRequest.method_name)
  return method_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvokeRequest::release_method_name() {
  // @@protoc_insertion_point(field_release:relayer.InvokeRequest.method_name)
  
  return method_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvokeRequest::set_allocated_method_name(::std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method_name);
  // @@protoc_insertion_point(field_set_allocated:relayer.InvokeRequest.method_name)
}

// map<string, bytes> args = 4;
inline int InvokeRequest::args_size() const {
  return args_.size();
}
inline void InvokeRequest::clear_args() {
  args_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
InvokeRequest::args() const {
  // @@protoc_insertion_point(field_map:relayer.InvokeRequest.args)
  return args_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
InvokeRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:relayer.InvokeRequest.args)
  return args_.MutableMap();
}

// repeated .relayer.ResourceLimit resource_limits = 5;
inline int InvokeRequest::resource_limits_size() const {
  return resource_limits_.size();
}
inline void InvokeRequest::clear_resource_limits() {
  resource_limits_.Clear();
}
inline ::relayer::ResourceLimit* InvokeRequest::mutable_resource_limits(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.InvokeRequest.resource_limits)
  return resource_limits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::ResourceLimit >*
InvokeRequest::mutable_resource_limits() {
  // @@protoc_insertion_point(field_mutable_list:relayer.InvokeRequest.resource_limits)
  return &resource_limits_;
}
inline const ::relayer::ResourceLimit& InvokeRequest::resource_limits(int index) const {
  // @@protoc_insertion_point(field_get:relayer.InvokeRequest.resource_limits)
  return resource_limits_.Get(index);
}
inline ::relayer::ResourceLimit* InvokeRequest::add_resource_limits() {
  // @@protoc_insertion_point(field_add:relayer.InvokeRequest.resource_limits)
  return resource_limits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::ResourceLimit >&
InvokeRequest::resource_limits() const {
  // @@protoc_insertion_point(field_list:relayer.InvokeRequest.resource_limits)
  return resource_limits_;
}

// string amount = 6;
inline void InvokeRequest::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvokeRequest::amount() const {
  // @@protoc_insertion_point(field_get:relayer.InvokeRequest.amount)
  return amount_.GetNoArena();
}
inline void InvokeRequest::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.InvokeRequest.amount)
}
#if LANG_CXX11
inline void InvokeRequest::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.InvokeRequest.amount)
}
#endif
inline void InvokeRequest::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.InvokeRequest.amount)
}
inline void InvokeRequest::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.InvokeRequest.amount)
}
inline ::std::string* InvokeRequest::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:relayer.InvokeRequest.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvokeRequest::release_amount() {
  // @@protoc_insertion_point(field_release:relayer.InvokeRequest.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvokeRequest::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:relayer.InvokeRequest.amount)
}

// -------------------------------------------------------------------

// SignatureInfo

// string PublicKey = 1;
inline void SignatureInfo::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignatureInfo::publickey() const {
  // @@protoc_insertion_point(field_get:relayer.SignatureInfo.PublicKey)
  return publickey_.GetNoArena();
}
inline void SignatureInfo::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.SignatureInfo.PublicKey)
}
#if LANG_CXX11
inline void SignatureInfo::set_publickey(::std::string&& value) {
  
  publickey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.SignatureInfo.PublicKey)
}
#endif
inline void SignatureInfo::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.SignatureInfo.PublicKey)
}
inline void SignatureInfo::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.SignatureInfo.PublicKey)
}
inline ::std::string* SignatureInfo::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:relayer.SignatureInfo.PublicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignatureInfo::release_publickey() {
  // @@protoc_insertion_point(field_release:relayer.SignatureInfo.PublicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_publickey(::std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:relayer.SignatureInfo.PublicKey)
}

// bytes Sign = 2;
inline void SignatureInfo::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignatureInfo::sign() const {
  // @@protoc_insertion_point(field_get:relayer.SignatureInfo.Sign)
  return sign_.GetNoArena();
}
inline void SignatureInfo::set_sign(const ::std::string& value) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.SignatureInfo.Sign)
}
#if LANG_CXX11
inline void SignatureInfo::set_sign(::std::string&& value) {
  
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.SignatureInfo.Sign)
}
#endif
inline void SignatureInfo::set_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.SignatureInfo.Sign)
}
inline void SignatureInfo::set_sign(const void* value, size_t size) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.SignatureInfo.Sign)
}
inline ::std::string* SignatureInfo::mutable_sign() {
  
  // @@protoc_insertion_point(field_mutable:relayer.SignatureInfo.Sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignatureInfo::release_sign() {
  // @@protoc_insertion_point(field_release:relayer.SignatureInfo.Sign)
  
  return sign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_sign(::std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:relayer.SignatureInfo.Sign)
}

// -------------------------------------------------------------------

// XuperSignature

// repeated bytes public_keys = 1;
inline int XuperSignature::public_keys_size() const {
  return public_keys_.size();
}
inline void XuperSignature::clear_public_keys() {
  public_keys_.Clear();
}
inline const ::std::string& XuperSignature::public_keys(int index) const {
  // @@protoc_insertion_point(field_get:relayer.XuperSignature.public_keys)
  return public_keys_.Get(index);
}
inline ::std::string* XuperSignature::mutable_public_keys(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.XuperSignature.public_keys)
  return public_keys_.Mutable(index);
}
inline void XuperSignature::set_public_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:relayer.XuperSignature.public_keys)
  public_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void XuperSignature::set_public_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:relayer.XuperSignature.public_keys)
  public_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void XuperSignature::set_public_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  public_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:relayer.XuperSignature.public_keys)
}
inline void XuperSignature::set_public_keys(int index, const void* value, size_t size) {
  public_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:relayer.XuperSignature.public_keys)
}
inline ::std::string* XuperSignature::add_public_keys() {
  // @@protoc_insertion_point(field_add_mutable:relayer.XuperSignature.public_keys)
  return public_keys_.Add();
}
inline void XuperSignature::add_public_keys(const ::std::string& value) {
  public_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:relayer.XuperSignature.public_keys)
}
#if LANG_CXX11
inline void XuperSignature::add_public_keys(::std::string&& value) {
  public_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:relayer.XuperSignature.public_keys)
}
#endif
inline void XuperSignature::add_public_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  public_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:relayer.XuperSignature.public_keys)
}
inline void XuperSignature::add_public_keys(const void* value, size_t size) {
  public_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:relayer.XuperSignature.public_keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
XuperSignature::public_keys() const {
  // @@protoc_insertion_point(field_list:relayer.XuperSignature.public_keys)
  return public_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
XuperSignature::mutable_public_keys() {
  // @@protoc_insertion_point(field_mutable_list:relayer.XuperSignature.public_keys)
  return &public_keys_;
}

// bytes signature = 2;
inline void XuperSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& XuperSignature::signature() const {
  // @@protoc_insertion_point(field_get:relayer.XuperSignature.signature)
  return signature_.GetNoArena();
}
inline void XuperSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.XuperSignature.signature)
}
#if LANG_CXX11
inline void XuperSignature::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.XuperSignature.signature)
}
#endif
inline void XuperSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.XuperSignature.signature)
}
inline void XuperSignature::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.XuperSignature.signature)
}
inline ::std::string* XuperSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:relayer.XuperSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XuperSignature::release_signature() {
  // @@protoc_insertion_point(field_release:relayer.XuperSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XuperSignature::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:relayer.XuperSignature.signature)
}

// -------------------------------------------------------------------

// ModifyBlock

// string effective_txid = 1;
inline void ModifyBlock::clear_effective_txid() {
  effective_txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModifyBlock::effective_txid() const {
  // @@protoc_insertion_point(field_get:relayer.ModifyBlock.effective_txid)
  return effective_txid_.GetNoArena();
}
inline void ModifyBlock::set_effective_txid(const ::std::string& value) {
  
  effective_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.ModifyBlock.effective_txid)
}
#if LANG_CXX11
inline void ModifyBlock::set_effective_txid(::std::string&& value) {
  
  effective_txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.ModifyBlock.effective_txid)
}
#endif
inline void ModifyBlock::set_effective_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  effective_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.ModifyBlock.effective_txid)
}
inline void ModifyBlock::set_effective_txid(const char* value, size_t size) {
  
  effective_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.ModifyBlock.effective_txid)
}
inline ::std::string* ModifyBlock::mutable_effective_txid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.ModifyBlock.effective_txid)
  return effective_txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModifyBlock::release_effective_txid() {
  // @@protoc_insertion_point(field_release:relayer.ModifyBlock.effective_txid)
  
  return effective_txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyBlock::set_allocated_effective_txid(::std::string* effective_txid) {
  if (effective_txid != nullptr) {
    
  } else {
    
  }
  effective_txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), effective_txid);
  // @@protoc_insertion_point(field_set_allocated:relayer.ModifyBlock.effective_txid)
}

// bool marked = 2;
inline void ModifyBlock::clear_marked() {
  marked_ = false;
}
inline bool ModifyBlock::marked() const {
  // @@protoc_insertion_point(field_get:relayer.ModifyBlock.marked)
  return marked_;
}
inline void ModifyBlock::set_marked(bool value) {
  
  marked_ = value;
  // @@protoc_insertion_point(field_set:relayer.ModifyBlock.marked)
}

// int64 effective_height = 3;
inline void ModifyBlock::clear_effective_height() {
  effective_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ModifyBlock::effective_height() const {
  // @@protoc_insertion_point(field_get:relayer.ModifyBlock.effective_height)
  return effective_height_;
}
inline void ModifyBlock::set_effective_height(::google::protobuf::int64 value) {
  
  effective_height_ = value;
  // @@protoc_insertion_point(field_set:relayer.ModifyBlock.effective_height)
}

// string public_key = 4;
inline void ModifyBlock::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModifyBlock::public_key() const {
  // @@protoc_insertion_point(field_get:relayer.ModifyBlock.public_key)
  return public_key_.GetNoArena();
}
inline void ModifyBlock::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.ModifyBlock.public_key)
}
#if LANG_CXX11
inline void ModifyBlock::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.ModifyBlock.public_key)
}
#endif
inline void ModifyBlock::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.ModifyBlock.public_key)
}
inline void ModifyBlock::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.ModifyBlock.public_key)
}
inline ::std::string* ModifyBlock::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:relayer.ModifyBlock.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModifyBlock::release_public_key() {
  // @@protoc_insertion_point(field_release:relayer.ModifyBlock.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyBlock::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:relayer.ModifyBlock.public_key)
}

// string sign = 5;
inline void ModifyBlock::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModifyBlock::sign() const {
  // @@protoc_insertion_point(field_get:relayer.ModifyBlock.sign)
  return sign_.GetNoArena();
}
inline void ModifyBlock::set_sign(const ::std::string& value) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.ModifyBlock.sign)
}
#if LANG_CXX11
inline void ModifyBlock::set_sign(::std::string&& value) {
  
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.ModifyBlock.sign)
}
#endif
inline void ModifyBlock::set_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.ModifyBlock.sign)
}
inline void ModifyBlock::set_sign(const char* value, size_t size) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.ModifyBlock.sign)
}
inline ::std::string* ModifyBlock::mutable_sign() {
  
  // @@protoc_insertion_point(field_mutable:relayer.ModifyBlock.sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModifyBlock::release_sign() {
  // @@protoc_insertion_point(field_release:relayer.ModifyBlock.sign)
  
  return sign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyBlock::set_allocated_sign(::std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:relayer.ModifyBlock.sign)
}

// -------------------------------------------------------------------

// ResourceLimit

// .relayer.ResourceType type = 1;
inline void ResourceLimit::clear_type() {
  type_ = 0;
}
inline ::relayer::ResourceType ResourceLimit::type() const {
  // @@protoc_insertion_point(field_get:relayer.ResourceLimit.type)
  return static_cast< ::relayer::ResourceType >(type_);
}
inline void ResourceLimit::set_type(::relayer::ResourceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:relayer.ResourceLimit.type)
}

// int64 limit = 2;
inline void ResourceLimit::clear_limit() {
  limit_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResourceLimit::limit() const {
  // @@protoc_insertion_point(field_get:relayer.ResourceLimit.limit)
  return limit_;
}
inline void ResourceLimit::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:relayer.ResourceLimit.limit)
}

// -------------------------------------------------------------------

// QuorumCert

// bytes ProposalId = 1;
inline void QuorumCert::clear_proposalid() {
  proposalid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QuorumCert::proposalid() const {
  // @@protoc_insertion_point(field_get:relayer.QuorumCert.ProposalId)
  return proposalid_.GetNoArena();
}
inline void QuorumCert::set_proposalid(const ::std::string& value) {
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.QuorumCert.ProposalId)
}
#if LANG_CXX11
inline void QuorumCert::set_proposalid(::std::string&& value) {
  
  proposalid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.QuorumCert.ProposalId)
}
#endif
inline void QuorumCert::set_proposalid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.QuorumCert.ProposalId)
}
inline void QuorumCert::set_proposalid(const void* value, size_t size) {
  
  proposalid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.QuorumCert.ProposalId)
}
inline ::std::string* QuorumCert::mutable_proposalid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.QuorumCert.ProposalId)
  return proposalid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuorumCert::release_proposalid() {
  // @@protoc_insertion_point(field_release:relayer.QuorumCert.ProposalId)
  
  return proposalid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuorumCert::set_allocated_proposalid(::std::string* proposalid) {
  if (proposalid != nullptr) {
    
  } else {
    
  }
  proposalid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposalid);
  // @@protoc_insertion_point(field_set_allocated:relayer.QuorumCert.ProposalId)
}

// bytes ProposalMsg = 2;
inline void QuorumCert::clear_proposalmsg() {
  proposalmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QuorumCert::proposalmsg() const {
  // @@protoc_insertion_point(field_get:relayer.QuorumCert.ProposalMsg)
  return proposalmsg_.GetNoArena();
}
inline void QuorumCert::set_proposalmsg(const ::std::string& value) {
  
  proposalmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.QuorumCert.ProposalMsg)
}
#if LANG_CXX11
inline void QuorumCert::set_proposalmsg(::std::string&& value) {
  
  proposalmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.QuorumCert.ProposalMsg)
}
#endif
inline void QuorumCert::set_proposalmsg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposalmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.QuorumCert.ProposalMsg)
}
inline void QuorumCert::set_proposalmsg(const void* value, size_t size) {
  
  proposalmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.QuorumCert.ProposalMsg)
}
inline ::std::string* QuorumCert::mutable_proposalmsg() {
  
  // @@protoc_insertion_point(field_mutable:relayer.QuorumCert.ProposalMsg)
  return proposalmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuorumCert::release_proposalmsg() {
  // @@protoc_insertion_point(field_release:relayer.QuorumCert.ProposalMsg)
  
  return proposalmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuorumCert::set_allocated_proposalmsg(::std::string* proposalmsg) {
  if (proposalmsg != nullptr) {
    
  } else {
    
  }
  proposalmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposalmsg);
  // @@protoc_insertion_point(field_set_allocated:relayer.QuorumCert.ProposalMsg)
}

// .relayer.QCState Type = 3;
inline void QuorumCert::clear_type() {
  type_ = 0;
}
inline ::relayer::QCState QuorumCert::type() const {
  // @@protoc_insertion_point(field_get:relayer.QuorumCert.Type)
  return static_cast< ::relayer::QCState >(type_);
}
inline void QuorumCert::set_type(::relayer::QCState value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:relayer.QuorumCert.Type)
}

// int64 ViewNumber = 4;
inline void QuorumCert::clear_viewnumber() {
  viewnumber_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 QuorumCert::viewnumber() const {
  // @@protoc_insertion_point(field_get:relayer.QuorumCert.ViewNumber)
  return viewnumber_;
}
inline void QuorumCert::set_viewnumber(::google::protobuf::int64 value) {
  
  viewnumber_ = value;
  // @@protoc_insertion_point(field_set:relayer.QuorumCert.ViewNumber)
}

// .relayer.QCSignInfos SignInfos = 5;
inline bool QuorumCert::has_signinfos() const {
  return this != internal_default_instance() && signinfos_ != nullptr;
}
inline void QuorumCert::clear_signinfos() {
  if (GetArenaNoVirtual() == nullptr && signinfos_ != nullptr) {
    delete signinfos_;
  }
  signinfos_ = nullptr;
}
inline const ::relayer::QCSignInfos& QuorumCert::signinfos() const {
  const ::relayer::QCSignInfos* p = signinfos_;
  // @@protoc_insertion_point(field_get:relayer.QuorumCert.SignInfos)
  return p != nullptr ? *p : *reinterpret_cast<const ::relayer::QCSignInfos*>(
      &::relayer::_QCSignInfos_default_instance_);
}
inline ::relayer::QCSignInfos* QuorumCert::release_signinfos() {
  // @@protoc_insertion_point(field_release:relayer.QuorumCert.SignInfos)
  
  ::relayer::QCSignInfos* temp = signinfos_;
  signinfos_ = nullptr;
  return temp;
}
inline ::relayer::QCSignInfos* QuorumCert::mutable_signinfos() {
  
  if (signinfos_ == nullptr) {
    auto* p = CreateMaybeMessage<::relayer::QCSignInfos>(GetArenaNoVirtual());
    signinfos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:relayer.QuorumCert.SignInfos)
  return signinfos_;
}
inline void QuorumCert::set_allocated_signinfos(::relayer::QCSignInfos* signinfos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signinfos_;
  }
  if (signinfos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signinfos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signinfos, submessage_arena);
    }
    
  } else {
    
  }
  signinfos_ = signinfos;
  // @@protoc_insertion_point(field_set_allocated:relayer.QuorumCert.SignInfos)
}

// -------------------------------------------------------------------

// QCSignInfos

// repeated .relayer.SignInfo QCSignInfos = 1;
inline int QCSignInfos::qcsigninfos_size() const {
  return qcsigninfos_.size();
}
inline void QCSignInfos::clear_qcsigninfos() {
  qcsigninfos_.Clear();
}
inline ::relayer::SignInfo* QCSignInfos::mutable_qcsigninfos(int index) {
  // @@protoc_insertion_point(field_mutable:relayer.QCSignInfos.QCSignInfos)
  return qcsigninfos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::relayer::SignInfo >*
QCSignInfos::mutable_qcsigninfos() {
  // @@protoc_insertion_point(field_mutable_list:relayer.QCSignInfos.QCSignInfos)
  return &qcsigninfos_;
}
inline const ::relayer::SignInfo& QCSignInfos::qcsigninfos(int index) const {
  // @@protoc_insertion_point(field_get:relayer.QCSignInfos.QCSignInfos)
  return qcsigninfos_.Get(index);
}
inline ::relayer::SignInfo* QCSignInfos::add_qcsigninfos() {
  // @@protoc_insertion_point(field_add:relayer.QCSignInfos.QCSignInfos)
  return qcsigninfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::relayer::SignInfo >&
QCSignInfos::qcsigninfos() const {
  // @@protoc_insertion_point(field_list:relayer.QCSignInfos.QCSignInfos)
  return qcsigninfos_;
}

// -------------------------------------------------------------------

// SignInfo

// string Address = 1;
inline void SignInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignInfo::address() const {
  // @@protoc_insertion_point(field_get:relayer.SignInfo.Address)
  return address_.GetNoArena();
}
inline void SignInfo::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.SignInfo.Address)
}
#if LANG_CXX11
inline void SignInfo::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.SignInfo.Address)
}
#endif
inline void SignInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.SignInfo.Address)
}
inline void SignInfo::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.SignInfo.Address)
}
inline ::std::string* SignInfo::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:relayer.SignInfo.Address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignInfo::release_address() {
  // @@protoc_insertion_point(field_release:relayer.SignInfo.Address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignInfo::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:relayer.SignInfo.Address)
}

// string PublicKey = 2;
inline void SignInfo::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignInfo::publickey() const {
  // @@protoc_insertion_point(field_get:relayer.SignInfo.PublicKey)
  return publickey_.GetNoArena();
}
inline void SignInfo::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.SignInfo.PublicKey)
}
#if LANG_CXX11
inline void SignInfo::set_publickey(::std::string&& value) {
  
  publickey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.SignInfo.PublicKey)
}
#endif
inline void SignInfo::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.SignInfo.PublicKey)
}
inline void SignInfo::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.SignInfo.PublicKey)
}
inline ::std::string* SignInfo::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:relayer.SignInfo.PublicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignInfo::release_publickey() {
  // @@protoc_insertion_point(field_release:relayer.SignInfo.PublicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignInfo::set_allocated_publickey(::std::string* publickey) {
  if (publickey != nullptr) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:relayer.SignInfo.PublicKey)
}

// bytes Sign = 3;
inline void SignInfo::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignInfo::sign() const {
  // @@protoc_insertion_point(field_get:relayer.SignInfo.Sign)
  return sign_.GetNoArena();
}
inline void SignInfo::set_sign(const ::std::string& value) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.SignInfo.Sign)
}
#if LANG_CXX11
inline void SignInfo::set_sign(::std::string&& value) {
  
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.SignInfo.Sign)
}
#endif
inline void SignInfo::set_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.SignInfo.Sign)
}
inline void SignInfo::set_sign(const void* value, size_t size) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.SignInfo.Sign)
}
inline ::std::string* SignInfo::mutable_sign() {
  
  // @@protoc_insertion_point(field_mutable:relayer.SignInfo.Sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignInfo::release_sign() {
  // @@protoc_insertion_point(field_release:relayer.SignInfo.Sign)
  
  return sign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignInfo::set_allocated_sign(::std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:relayer.SignInfo.Sign)
}

// -------------------------------------------------------------------

// LedgerMeta

// string root_blockid = 1;
inline void LedgerMeta::clear_root_blockid() {
  root_blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerMeta::root_blockid() const {
  // @@protoc_insertion_point(field_get:relayer.LedgerMeta.root_blockid)
  return root_blockid_.GetNoArena();
}
inline void LedgerMeta::set_root_blockid(const ::std::string& value) {
  
  root_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.LedgerMeta.root_blockid)
}
#if LANG_CXX11
inline void LedgerMeta::set_root_blockid(::std::string&& value) {
  
  root_blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.LedgerMeta.root_blockid)
}
#endif
inline void LedgerMeta::set_root_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  root_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.LedgerMeta.root_blockid)
}
inline void LedgerMeta::set_root_blockid(const char* value, size_t size) {
  
  root_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.LedgerMeta.root_blockid)
}
inline ::std::string* LedgerMeta::mutable_root_blockid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.LedgerMeta.root_blockid)
  return root_blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerMeta::release_root_blockid() {
  // @@protoc_insertion_point(field_release:relayer.LedgerMeta.root_blockid)
  
  return root_blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerMeta::set_allocated_root_blockid(::std::string* root_blockid) {
  if (root_blockid != nullptr) {
    
  } else {
    
  }
  root_blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root_blockid);
  // @@protoc_insertion_point(field_set_allocated:relayer.LedgerMeta.root_blockid)
}

// string tip_blockid = 2;
inline void LedgerMeta::clear_tip_blockid() {
  tip_blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerMeta::tip_blockid() const {
  // @@protoc_insertion_point(field_get:relayer.LedgerMeta.tip_blockid)
  return tip_blockid_.GetNoArena();
}
inline void LedgerMeta::set_tip_blockid(const ::std::string& value) {
  
  tip_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:relayer.LedgerMeta.tip_blockid)
}
#if LANG_CXX11
inline void LedgerMeta::set_tip_blockid(::std::string&& value) {
  
  tip_blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:relayer.LedgerMeta.tip_blockid)
}
#endif
inline void LedgerMeta::set_tip_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tip_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:relayer.LedgerMeta.tip_blockid)
}
inline void LedgerMeta::set_tip_blockid(const char* value, size_t size) {
  
  tip_blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:relayer.LedgerMeta.tip_blockid)
}
inline ::std::string* LedgerMeta::mutable_tip_blockid() {
  
  // @@protoc_insertion_point(field_mutable:relayer.LedgerMeta.tip_blockid)
  return tip_blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerMeta::release_tip_blockid() {
  // @@protoc_insertion_point(field_release:relayer.LedgerMeta.tip_blockid)
  
  return tip_blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerMeta::set_allocated_tip_blockid(::std::string* tip_blockid) {
  if (tip_blockid != nullptr) {
    
  } else {
    
  }
  tip_blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tip_blockid);
  // @@protoc_insertion_point(field_set_allocated:relayer.LedgerMeta.tip_blockid)
}

// int64 trunk_height = 3;
inline void LedgerMeta::clear_trunk_height() {
  trunk_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerMeta::trunk_height() const {
  // @@protoc_insertion_point(field_get:relayer.LedgerMeta.trunk_height)
  return trunk_height_;
}
inline void LedgerMeta::set_trunk_height(::google::protobuf::int64 value) {
  
  trunk_height_ = value;
  // @@protoc_insertion_point(field_set:relayer.LedgerMeta.trunk_height)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace relayer

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::relayer::ResourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::relayer::QCState> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_relayer_2eproto
