// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contract.proto

#ifndef PROTOBUF_INCLUDED_contract_2eproto
#define PROTOBUF_INCLUDED_contract_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_contract_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_contract_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace xchain {
namespace contract {
namespace sdk {
class ArgPair;
class ArgPairDefaultTypeInternal;
extern ArgPairDefaultTypeInternal _ArgPair_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class CallArgs;
class CallArgsDefaultTypeInternal;
extern CallArgsDefaultTypeInternal _CallArgs_default_instance_;
class ContractCallRequest;
class ContractCallRequestDefaultTypeInternal;
extern ContractCallRequestDefaultTypeInternal _ContractCallRequest_default_instance_;
class ContractCallResponse;
class ContractCallResponseDefaultTypeInternal;
extern ContractCallResponseDefaultTypeInternal _ContractCallResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetAccountAddressesRequest;
class GetAccountAddressesRequestDefaultTypeInternal;
extern GetAccountAddressesRequestDefaultTypeInternal _GetAccountAddressesRequest_default_instance_;
class GetAccountAddressesResponse;
class GetAccountAddressesResponseDefaultTypeInternal;
extern GetAccountAddressesResponseDefaultTypeInternal _GetAccountAddressesResponse_default_instance_;
class GetCallArgsRequest;
class GetCallArgsRequestDefaultTypeInternal;
extern GetCallArgsRequestDefaultTypeInternal _GetCallArgsRequest_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class IteratorItem;
class IteratorItemDefaultTypeInternal;
extern IteratorItemDefaultTypeInternal _IteratorItem_default_instance_;
class IteratorRequest;
class IteratorRequestDefaultTypeInternal;
extern IteratorRequestDefaultTypeInternal _IteratorRequest_default_instance_;
class IteratorResponse;
class IteratorResponseDefaultTypeInternal;
extern IteratorResponseDefaultTypeInternal _IteratorResponse_default_instance_;
class NativeCallRequest;
class NativeCallRequestDefaultTypeInternal;
extern NativeCallRequestDefaultTypeInternal _NativeCallRequest_default_instance_;
class NativeCallResponse;
class NativeCallResponseDefaultTypeInternal;
extern NativeCallResponseDefaultTypeInternal _NativeCallResponse_default_instance_;
class PingRequest;
class PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
class PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class PutRequest;
class PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
class PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class QueryBlockRequest;
class QueryBlockRequestDefaultTypeInternal;
extern QueryBlockRequestDefaultTypeInternal _QueryBlockRequest_default_instance_;
class QueryBlockResponse;
class QueryBlockResponseDefaultTypeInternal;
extern QueryBlockResponseDefaultTypeInternal _QueryBlockResponse_default_instance_;
class QueryTxRequest;
class QueryTxRequestDefaultTypeInternal;
extern QueryTxRequestDefaultTypeInternal _QueryTxRequest_default_instance_;
class QueryTxResponse;
class QueryTxResponseDefaultTypeInternal;
extern QueryTxResponseDefaultTypeInternal _QueryTxResponse_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SetOutputRequest;
class SetOutputRequestDefaultTypeInternal;
extern SetOutputRequestDefaultTypeInternal _SetOutputRequest_default_instance_;
class SetOutputResponse;
class SetOutputResponseDefaultTypeInternal;
extern SetOutputResponseDefaultTypeInternal _SetOutputResponse_default_instance_;
class SyscallHeader;
class SyscallHeaderDefaultTypeInternal;
extern SyscallHeaderDefaultTypeInternal _SyscallHeader_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferRequest;
class TransferRequestDefaultTypeInternal;
extern TransferRequestDefaultTypeInternal _TransferRequest_default_instance_;
class TransferResponse;
class TransferResponseDefaultTypeInternal;
extern TransferResponseDefaultTypeInternal _TransferResponse_default_instance_;
class TxInput;
class TxInputDefaultTypeInternal;
extern TxInputDefaultTypeInternal _TxInput_default_instance_;
class TxOutput;
class TxOutputDefaultTypeInternal;
extern TxOutputDefaultTypeInternal _TxOutput_default_instance_;
}  // namespace sdk
}  // namespace contract
}  // namespace xchain
namespace google {
namespace protobuf {
template<> ::xchain::contract::sdk::ArgPair* Arena::CreateMaybeMessage<::xchain::contract::sdk::ArgPair>(Arena*);
template<> ::xchain::contract::sdk::Block* Arena::CreateMaybeMessage<::xchain::contract::sdk::Block>(Arena*);
template<> ::xchain::contract::sdk::CallArgs* Arena::CreateMaybeMessage<::xchain::contract::sdk::CallArgs>(Arena*);
template<> ::xchain::contract::sdk::ContractCallRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::ContractCallRequest>(Arena*);
template<> ::xchain::contract::sdk::ContractCallResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::ContractCallResponse>(Arena*);
template<> ::xchain::contract::sdk::DeleteRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::DeleteRequest>(Arena*);
template<> ::xchain::contract::sdk::DeleteResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::DeleteResponse>(Arena*);
template<> ::xchain::contract::sdk::GetAccountAddressesRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::GetAccountAddressesRequest>(Arena*);
template<> ::xchain::contract::sdk::GetAccountAddressesResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::GetAccountAddressesResponse>(Arena*);
template<> ::xchain::contract::sdk::GetCallArgsRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::GetCallArgsRequest>(Arena*);
template<> ::xchain::contract::sdk::GetRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::GetRequest>(Arena*);
template<> ::xchain::contract::sdk::GetResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::GetResponse>(Arena*);
template<> ::xchain::contract::sdk::IteratorItem* Arena::CreateMaybeMessage<::xchain::contract::sdk::IteratorItem>(Arena*);
template<> ::xchain::contract::sdk::IteratorRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::IteratorRequest>(Arena*);
template<> ::xchain::contract::sdk::IteratorResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::IteratorResponse>(Arena*);
template<> ::xchain::contract::sdk::NativeCallRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::NativeCallRequest>(Arena*);
template<> ::xchain::contract::sdk::NativeCallResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::NativeCallResponse>(Arena*);
template<> ::xchain::contract::sdk::PingRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::PingRequest>(Arena*);
template<> ::xchain::contract::sdk::PingResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::PingResponse>(Arena*);
template<> ::xchain::contract::sdk::PutRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::PutRequest>(Arena*);
template<> ::xchain::contract::sdk::PutResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::PutResponse>(Arena*);
template<> ::xchain::contract::sdk::QueryBlockRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::QueryBlockRequest>(Arena*);
template<> ::xchain::contract::sdk::QueryBlockResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::QueryBlockResponse>(Arena*);
template<> ::xchain::contract::sdk::QueryTxRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::QueryTxRequest>(Arena*);
template<> ::xchain::contract::sdk::QueryTxResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::QueryTxResponse>(Arena*);
template<> ::xchain::contract::sdk::Response* Arena::CreateMaybeMessage<::xchain::contract::sdk::Response>(Arena*);
template<> ::xchain::contract::sdk::SetOutputRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::SetOutputRequest>(Arena*);
template<> ::xchain::contract::sdk::SetOutputResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::SetOutputResponse>(Arena*);
template<> ::xchain::contract::sdk::SyscallHeader* Arena::CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(Arena*);
template<> ::xchain::contract::sdk::Transaction* Arena::CreateMaybeMessage<::xchain::contract::sdk::Transaction>(Arena*);
template<> ::xchain::contract::sdk::TransferRequest* Arena::CreateMaybeMessage<::xchain::contract::sdk::TransferRequest>(Arena*);
template<> ::xchain::contract::sdk::TransferResponse* Arena::CreateMaybeMessage<::xchain::contract::sdk::TransferResponse>(Arena*);
template<> ::xchain::contract::sdk::TxInput* Arena::CreateMaybeMessage<::xchain::contract::sdk::TxInput>(Arena*);
template<> ::xchain::contract::sdk::TxOutput* Arena::CreateMaybeMessage<::xchain::contract::sdk::TxOutput>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace xchain {
namespace contract {
namespace sdk {

// ===================================================================

class PingRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.PingRequest) */ {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PingRequest* other);
  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return CreateMaybeMessage<PingRequest>(nullptr);
  }

  PingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.PingRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class PingResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.PingResponse) */ {
 public:
  PingResponse();
  virtual ~PingResponse();

  PingResponse(const PingResponse& from);

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PingResponse* other);
  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return CreateMaybeMessage<PingResponse>(nullptr);
  }

  PingResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PingResponse& from);
  void MergeFrom(const PingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.PingResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class NativeCallRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.NativeCallRequest) */ {
 public:
  NativeCallRequest();
  virtual ~NativeCallRequest();

  NativeCallRequest(const NativeCallRequest& from);

  inline NativeCallRequest& operator=(const NativeCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NativeCallRequest(NativeCallRequest&& from) noexcept
    : NativeCallRequest() {
    *this = ::std::move(from);
  }

  inline NativeCallRequest& operator=(NativeCallRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NativeCallRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NativeCallRequest* internal_default_instance() {
    return reinterpret_cast<const NativeCallRequest*>(
               &_NativeCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NativeCallRequest* other);
  friend void swap(NativeCallRequest& a, NativeCallRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NativeCallRequest* New() const final {
    return CreateMaybeMessage<NativeCallRequest>(nullptr);
  }

  NativeCallRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NativeCallRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const NativeCallRequest& from);
  void MergeFrom(const NativeCallRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NativeCallRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 ctxid = 1;
  void clear_ctxid();
  static const int kCtxidFieldNumber = 1;
  ::google::protobuf::int64 ctxid() const;
  void set_ctxid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.NativeCallRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 ctxid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class NativeCallResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.NativeCallResponse) */ {
 public:
  NativeCallResponse();
  virtual ~NativeCallResponse();

  NativeCallResponse(const NativeCallResponse& from);

  inline NativeCallResponse& operator=(const NativeCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NativeCallResponse(NativeCallResponse&& from) noexcept
    : NativeCallResponse() {
    *this = ::std::move(from);
  }

  inline NativeCallResponse& operator=(NativeCallResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NativeCallResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NativeCallResponse* internal_default_instance() {
    return reinterpret_cast<const NativeCallResponse*>(
               &_NativeCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NativeCallResponse* other);
  friend void swap(NativeCallResponse& a, NativeCallResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NativeCallResponse* New() const final {
    return CreateMaybeMessage<NativeCallResponse>(nullptr);
  }

  NativeCallResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NativeCallResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const NativeCallResponse& from);
  void MergeFrom(const NativeCallResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NativeCallResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.NativeCallResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class ArgPair :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.ArgPair) */ {
 public:
  ArgPair();
  virtual ~ArgPair();

  ArgPair(const ArgPair& from);

  inline ArgPair& operator=(const ArgPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArgPair(ArgPair&& from) noexcept
    : ArgPair() {
    *this = ::std::move(from);
  }

  inline ArgPair& operator=(ArgPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ArgPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArgPair* internal_default_instance() {
    return reinterpret_cast<const ArgPair*>(
               &_ArgPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ArgPair* other);
  friend void swap(ArgPair& a, ArgPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArgPair* New() const final {
    return CreateMaybeMessage<ArgPair>(nullptr);
  }

  ArgPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArgPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ArgPair& from);
  void MergeFrom(const ArgPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ArgPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.ArgPair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class CallArgs :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.CallArgs) */ {
 public:
  CallArgs();
  virtual ~CallArgs();

  CallArgs(const CallArgs& from);

  inline CallArgs& operator=(const CallArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CallArgs(CallArgs&& from) noexcept
    : CallArgs() {
    *this = ::std::move(from);
  }

  inline CallArgs& operator=(CallArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CallArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CallArgs* internal_default_instance() {
    return reinterpret_cast<const CallArgs*>(
               &_CallArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CallArgs* other);
  friend void swap(CallArgs& a, CallArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CallArgs* New() const final {
    return CreateMaybeMessage<CallArgs>(nullptr);
  }

  CallArgs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CallArgs>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CallArgs& from);
  void MergeFrom(const CallArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xchain.contract.sdk.ArgPair args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::xchain::contract::sdk::ArgPair* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >*
      mutable_args();
  const ::xchain::contract::sdk::ArgPair& args(int index) const;
  ::xchain::contract::sdk::ArgPair* add_args();
  const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >&
      args() const;

  // repeated string auth_require = 4;
  int auth_require_size() const;
  void clear_auth_require();
  static const int kAuthRequireFieldNumber = 4;
  const ::std::string& auth_require(int index) const;
  ::std::string* mutable_auth_require(int index);
  void set_auth_require(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_auth_require(int index, ::std::string&& value);
  #endif
  void set_auth_require(int index, const char* value);
  void set_auth_require(int index, const char* value, size_t size);
  ::std::string* add_auth_require();
  void add_auth_require(const ::std::string& value);
  #if LANG_CXX11
  void add_auth_require(::std::string&& value);
  #endif
  void add_auth_require(const char* value);
  void add_auth_require(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& auth_require() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_auth_require();

  // string method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // string initiator = 3;
  void clear_initiator();
  static const int kInitiatorFieldNumber = 3;
  const ::std::string& initiator() const;
  void set_initiator(const ::std::string& value);
  #if LANG_CXX11
  void set_initiator(::std::string&& value);
  #endif
  void set_initiator(const char* value);
  void set_initiator(const char* value, size_t size);
  ::std::string* mutable_initiator();
  ::std::string* release_initiator();
  void set_allocated_initiator(::std::string* initiator);

  // string transfer_amount = 5;
  void clear_transfer_amount();
  static const int kTransferAmountFieldNumber = 5;
  const ::std::string& transfer_amount() const;
  void set_transfer_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_amount(::std::string&& value);
  #endif
  void set_transfer_amount(const char* value);
  void set_transfer_amount(const char* value, size_t size);
  ::std::string* mutable_transfer_amount();
  ::std::string* release_transfer_amount();
  void set_allocated_transfer_amount(::std::string* transfer_amount);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.CallArgs)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair > args_;
  ::google::protobuf::RepeatedPtrField<::std::string> auth_require_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::google::protobuf::internal::ArenaStringPtr initiator_;
  ::google::protobuf::internal::ArenaStringPtr transfer_amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SyscallHeader :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.SyscallHeader) */ {
 public:
  SyscallHeader();
  virtual ~SyscallHeader();

  SyscallHeader(const SyscallHeader& from);

  inline SyscallHeader& operator=(const SyscallHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyscallHeader(SyscallHeader&& from) noexcept
    : SyscallHeader() {
    *this = ::std::move(from);
  }

  inline SyscallHeader& operator=(SyscallHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SyscallHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyscallHeader* internal_default_instance() {
    return reinterpret_cast<const SyscallHeader*>(
               &_SyscallHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SyscallHeader* other);
  friend void swap(SyscallHeader& a, SyscallHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyscallHeader* New() const final {
    return CreateMaybeMessage<SyscallHeader>(nullptr);
  }

  SyscallHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyscallHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SyscallHeader& from);
  void MergeFrom(const SyscallHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SyscallHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 ctxid = 1;
  void clear_ctxid();
  static const int kCtxidFieldNumber = 1;
  ::google::protobuf::int64 ctxid() const;
  void set_ctxid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.SyscallHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 ctxid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class PutRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.PutRequest) */ {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PutRequest* other);
  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutRequest* New() const final {
    return CreateMaybeMessage<PutRequest>(nullptr);
  }

  PutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.PutRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class PutResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.PutResponse) */ {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PutResponse* other);
  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutResponse* New() const final {
    return CreateMaybeMessage<PutResponse>(nullptr);
  }

  PutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.PutResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.GetRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetResponse* other);
  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.GetResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(nullptr);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.DeleteRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(nullptr);
  }

  DeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.DeleteResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class IteratorRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.IteratorRequest) */ {
 public:
  IteratorRequest();
  virtual ~IteratorRequest();

  IteratorRequest(const IteratorRequest& from);

  inline IteratorRequest& operator=(const IteratorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IteratorRequest(IteratorRequest&& from) noexcept
    : IteratorRequest() {
    *this = ::std::move(from);
  }

  inline IteratorRequest& operator=(IteratorRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IteratorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IteratorRequest* internal_default_instance() {
    return reinterpret_cast<const IteratorRequest*>(
               &_IteratorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(IteratorRequest* other);
  friend void swap(IteratorRequest& a, IteratorRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IteratorRequest* New() const final {
    return CreateMaybeMessage<IteratorRequest>(nullptr);
  }

  IteratorRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IteratorRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IteratorRequest& from);
  void MergeFrom(const IteratorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IteratorRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start = 2;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // bytes limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  const ::std::string& limit() const;
  void set_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_limit(::std::string&& value);
  #endif
  void set_limit(const char* value);
  void set_limit(const void* value, size_t size);
  ::std::string* mutable_limit();
  ::std::string* release_limit();
  void set_allocated_limit(::std::string* limit);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // int32 cap = 4;
  void clear_cap();
  static const int kCapFieldNumber = 4;
  ::google::protobuf::int32 cap() const;
  void set_cap(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.IteratorRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr limit_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  ::google::protobuf::int32 cap_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class IteratorItem :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.IteratorItem) */ {
 public:
  IteratorItem();
  virtual ~IteratorItem();

  IteratorItem(const IteratorItem& from);

  inline IteratorItem& operator=(const IteratorItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IteratorItem(IteratorItem&& from) noexcept
    : IteratorItem() {
    *this = ::std::move(from);
  }

  inline IteratorItem& operator=(IteratorItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IteratorItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IteratorItem* internal_default_instance() {
    return reinterpret_cast<const IteratorItem*>(
               &_IteratorItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(IteratorItem* other);
  friend void swap(IteratorItem& a, IteratorItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IteratorItem* New() const final {
    return CreateMaybeMessage<IteratorItem>(nullptr);
  }

  IteratorItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IteratorItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IteratorItem& from);
  void MergeFrom(const IteratorItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IteratorItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.IteratorItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class IteratorResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.IteratorResponse) */ {
 public:
  IteratorResponse();
  virtual ~IteratorResponse();

  IteratorResponse(const IteratorResponse& from);

  inline IteratorResponse& operator=(const IteratorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IteratorResponse(IteratorResponse&& from) noexcept
    : IteratorResponse() {
    *this = ::std::move(from);
  }

  inline IteratorResponse& operator=(IteratorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IteratorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IteratorResponse* internal_default_instance() {
    return reinterpret_cast<const IteratorResponse*>(
               &_IteratorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(IteratorResponse* other);
  friend void swap(IteratorResponse& a, IteratorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IteratorResponse* New() const final {
    return CreateMaybeMessage<IteratorResponse>(nullptr);
  }

  IteratorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IteratorResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IteratorResponse& from);
  void MergeFrom(const IteratorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IteratorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xchain.contract.sdk.IteratorItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  ::xchain::contract::sdk::IteratorItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::IteratorItem >*
      mutable_items();
  const ::xchain::contract::sdk::IteratorItem& items(int index) const;
  ::xchain::contract::sdk::IteratorItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::IteratorItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.IteratorResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::IteratorItem > items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class QueryTxRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.QueryTxRequest) */ {
 public:
  QueryTxRequest();
  virtual ~QueryTxRequest();

  QueryTxRequest(const QueryTxRequest& from);

  inline QueryTxRequest& operator=(const QueryTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryTxRequest(QueryTxRequest&& from) noexcept
    : QueryTxRequest() {
    *this = ::std::move(from);
  }

  inline QueryTxRequest& operator=(QueryTxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryTxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryTxRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTxRequest*>(
               &_QueryTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(QueryTxRequest* other);
  friend void swap(QueryTxRequest& a, QueryTxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryTxRequest* New() const final {
    return CreateMaybeMessage<QueryTxRequest>(nullptr);
  }

  QueryTxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryTxRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryTxRequest& from);
  void MergeFrom(const QueryTxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string txid = 2;
  void clear_txid();
  static const int kTxidFieldNumber = 2;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const char* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.QueryTxRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class QueryTxResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.QueryTxResponse) */ {
 public:
  QueryTxResponse();
  virtual ~QueryTxResponse();

  QueryTxResponse(const QueryTxResponse& from);

  inline QueryTxResponse& operator=(const QueryTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryTxResponse(QueryTxResponse&& from) noexcept
    : QueryTxResponse() {
    *this = ::std::move(from);
  }

  inline QueryTxResponse& operator=(QueryTxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryTxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryTxResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTxResponse*>(
               &_QueryTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(QueryTxResponse* other);
  friend void swap(QueryTxResponse& a, QueryTxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryTxResponse* New() const final {
    return CreateMaybeMessage<QueryTxResponse>(nullptr);
  }

  QueryTxResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryTxResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryTxResponse& from);
  void MergeFrom(const QueryTxResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryTxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xchain.contract.sdk.Transaction tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::xchain::contract::sdk::Transaction& tx() const;
  ::xchain::contract::sdk::Transaction* release_tx();
  ::xchain::contract::sdk::Transaction* mutable_tx();
  void set_allocated_tx(::xchain::contract::sdk::Transaction* tx);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.QueryTxResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::xchain::contract::sdk::Transaction* tx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class QueryBlockRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.QueryBlockRequest) */ {
 public:
  QueryBlockRequest();
  virtual ~QueryBlockRequest();

  QueryBlockRequest(const QueryBlockRequest& from);

  inline QueryBlockRequest& operator=(const QueryBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryBlockRequest(QueryBlockRequest&& from) noexcept
    : QueryBlockRequest() {
    *this = ::std::move(from);
  }

  inline QueryBlockRequest& operator=(QueryBlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryBlockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryBlockRequest* internal_default_instance() {
    return reinterpret_cast<const QueryBlockRequest*>(
               &_QueryBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(QueryBlockRequest* other);
  friend void swap(QueryBlockRequest& a, QueryBlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryBlockRequest* New() const final {
    return CreateMaybeMessage<QueryBlockRequest>(nullptr);
  }

  QueryBlockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryBlockRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryBlockRequest& from);
  void MergeFrom(const QueryBlockRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryBlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string blockid = 2;
  void clear_blockid();
  static const int kBlockidFieldNumber = 2;
  const ::std::string& blockid() const;
  void set_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockid(::std::string&& value);
  #endif
  void set_blockid(const char* value);
  void set_blockid(const char* value, size_t size);
  ::std::string* mutable_blockid();
  ::std::string* release_blockid();
  void set_allocated_blockid(::std::string* blockid);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.QueryBlockRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blockid_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class QueryBlockResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.QueryBlockResponse) */ {
 public:
  QueryBlockResponse();
  virtual ~QueryBlockResponse();

  QueryBlockResponse(const QueryBlockResponse& from);

  inline QueryBlockResponse& operator=(const QueryBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryBlockResponse(QueryBlockResponse&& from) noexcept
    : QueryBlockResponse() {
    *this = ::std::move(from);
  }

  inline QueryBlockResponse& operator=(QueryBlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const QueryBlockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryBlockResponse* internal_default_instance() {
    return reinterpret_cast<const QueryBlockResponse*>(
               &_QueryBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(QueryBlockResponse* other);
  friend void swap(QueryBlockResponse& a, QueryBlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryBlockResponse* New() const final {
    return CreateMaybeMessage<QueryBlockResponse>(nullptr);
  }

  QueryBlockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryBlockResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const QueryBlockResponse& from);
  void MergeFrom(const QueryBlockResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryBlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xchain.contract.sdk.Block block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  const ::xchain::contract::sdk::Block& block() const;
  ::xchain::contract::sdk::Block* release_block();
  ::xchain::contract::sdk::Block* mutable_block();
  void set_allocated_block(::xchain::contract::sdk::Block* block);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.QueryBlockResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::xchain::contract::sdk::Block* block_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TransferRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.TransferRequest) */ {
 public:
  TransferRequest();
  virtual ~TransferRequest();

  TransferRequest(const TransferRequest& from);

  inline TransferRequest& operator=(const TransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferRequest(TransferRequest&& from) noexcept
    : TransferRequest() {
    *this = ::std::move(from);
  }

  inline TransferRequest& operator=(TransferRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TransferRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferRequest* internal_default_instance() {
    return reinterpret_cast<const TransferRequest*>(
               &_TransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(TransferRequest* other);
  friend void swap(TransferRequest& a, TransferRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferRequest* New() const final {
    return CreateMaybeMessage<TransferRequest>(nullptr);
  }

  TransferRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TransferRequest& from);
  void MergeFrom(const TransferRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransferRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string amount = 4;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.TransferRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TransferResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.TransferResponse) */ {
 public:
  TransferResponse();
  virtual ~TransferResponse();

  TransferResponse(const TransferResponse& from);

  inline TransferResponse& operator=(const TransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferResponse(TransferResponse&& from) noexcept
    : TransferResponse() {
    *this = ::std::move(from);
  }

  inline TransferResponse& operator=(TransferResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TransferResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferResponse* internal_default_instance() {
    return reinterpret_cast<const TransferResponse*>(
               &_TransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(TransferResponse* other);
  friend void swap(TransferResponse& a, TransferResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferResponse* New() const final {
    return CreateMaybeMessage<TransferResponse>(nullptr);
  }

  TransferResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TransferResponse& from);
  void MergeFrom(const TransferResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransferResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.TransferResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class ContractCallRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.ContractCallRequest) */ {
 public:
  ContractCallRequest();
  virtual ~ContractCallRequest();

  ContractCallRequest(const ContractCallRequest& from);

  inline ContractCallRequest& operator=(const ContractCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractCallRequest(ContractCallRequest&& from) noexcept
    : ContractCallRequest() {
    *this = ::std::move(from);
  }

  inline ContractCallRequest& operator=(ContractCallRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ContractCallRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractCallRequest* internal_default_instance() {
    return reinterpret_cast<const ContractCallRequest*>(
               &_ContractCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ContractCallRequest* other);
  friend void swap(ContractCallRequest& a, ContractCallRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractCallRequest* New() const final {
    return CreateMaybeMessage<ContractCallRequest>(nullptr);
  }

  ContractCallRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContractCallRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ContractCallRequest& from);
  void MergeFrom(const ContractCallRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContractCallRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xchain.contract.sdk.ArgPair args = 5;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 5;
  ::xchain::contract::sdk::ArgPair* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >*
      mutable_args();
  const ::xchain::contract::sdk::ArgPair& args(int index) const;
  ::xchain::contract::sdk::ArgPair* add_args();
  const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >&
      args() const;

  // string module = 2;
  void clear_module();
  static const int kModuleFieldNumber = 2;
  const ::std::string& module() const;
  void set_module(const ::std::string& value);
  #if LANG_CXX11
  void set_module(::std::string&& value);
  #endif
  void set_module(const char* value);
  void set_module(const char* value, size_t size);
  ::std::string* mutable_module();
  ::std::string* release_module();
  void set_allocated_module(::std::string* module);

  // string contract = 3;
  void clear_contract();
  static const int kContractFieldNumber = 3;
  const ::std::string& contract() const;
  void set_contract(const ::std::string& value);
  #if LANG_CXX11
  void set_contract(::std::string&& value);
  #endif
  void set_contract(const char* value);
  void set_contract(const char* value, size_t size);
  ::std::string* mutable_contract();
  ::std::string* release_contract();
  void set_allocated_contract(::std::string* contract);

  // string method = 4;
  void clear_method();
  static const int kMethodFieldNumber = 4;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.ContractCallRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair > args_;
  ::google::protobuf::internal::ArenaStringPtr module_;
  ::google::protobuf::internal::ArenaStringPtr contract_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class ContractCallResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.ContractCallResponse) */ {
 public:
  ContractCallResponse();
  virtual ~ContractCallResponse();

  ContractCallResponse(const ContractCallResponse& from);

  inline ContractCallResponse& operator=(const ContractCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractCallResponse(ContractCallResponse&& from) noexcept
    : ContractCallResponse() {
    *this = ::std::move(from);
  }

  inline ContractCallResponse& operator=(ContractCallResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ContractCallResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractCallResponse* internal_default_instance() {
    return reinterpret_cast<const ContractCallResponse*>(
               &_ContractCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ContractCallResponse* other);
  friend void swap(ContractCallResponse& a, ContractCallResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractCallResponse* New() const final {
    return CreateMaybeMessage<ContractCallResponse>(nullptr);
  }

  ContractCallResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContractCallResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ContractCallResponse& from);
  void MergeFrom(const ContractCallResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContractCallResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xchain.contract.sdk.Response response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  const ::xchain::contract::sdk::Response& response() const;
  ::xchain::contract::sdk::Response* release_response();
  ::xchain::contract::sdk::Response* mutable_response();
  void set_allocated_response(::xchain::contract::sdk::Response* response);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.ContractCallResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::xchain::contract::sdk::Response* response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bytes body = 3;
  void clear_body();
  static const int kBodyFieldNumber = 3;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.Response)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::int32 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SetOutputRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.SetOutputRequest) */ {
 public:
  SetOutputRequest();
  virtual ~SetOutputRequest();

  SetOutputRequest(const SetOutputRequest& from);

  inline SetOutputRequest& operator=(const SetOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetOutputRequest(SetOutputRequest&& from) noexcept
    : SetOutputRequest() {
    *this = ::std::move(from);
  }

  inline SetOutputRequest& operator=(SetOutputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetOutputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetOutputRequest* internal_default_instance() {
    return reinterpret_cast<const SetOutputRequest*>(
               &_SetOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(SetOutputRequest* other);
  friend void swap(SetOutputRequest& a, SetOutputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetOutputRequest* New() const final {
    return CreateMaybeMessage<SetOutputRequest>(nullptr);
  }

  SetOutputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetOutputRequest& from);
  void MergeFrom(const SetOutputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetOutputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // .xchain.contract.sdk.Response response = 2;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 2;
  const ::xchain::contract::sdk::Response& response() const;
  ::xchain::contract::sdk::Response* release_response();
  ::xchain::contract::sdk::Response* mutable_response();
  void set_allocated_response(::xchain::contract::sdk::Response* response);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.SetOutputRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  ::xchain::contract::sdk::Response* response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class SetOutputResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.SetOutputResponse) */ {
 public:
  SetOutputResponse();
  virtual ~SetOutputResponse();

  SetOutputResponse(const SetOutputResponse& from);

  inline SetOutputResponse& operator=(const SetOutputResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetOutputResponse(SetOutputResponse&& from) noexcept
    : SetOutputResponse() {
    *this = ::std::move(from);
  }

  inline SetOutputResponse& operator=(SetOutputResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetOutputResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetOutputResponse* internal_default_instance() {
    return reinterpret_cast<const SetOutputResponse*>(
               &_SetOutputResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(SetOutputResponse* other);
  friend void swap(SetOutputResponse& a, SetOutputResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetOutputResponse* New() const final {
    return CreateMaybeMessage<SetOutputResponse>(nullptr);
  }

  SetOutputResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetOutputResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetOutputResponse& from);
  void MergeFrom(const SetOutputResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetOutputResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.SetOutputResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetCallArgsRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.GetCallArgsRequest) */ {
 public:
  GetCallArgsRequest();
  virtual ~GetCallArgsRequest();

  GetCallArgsRequest(const GetCallArgsRequest& from);

  inline GetCallArgsRequest& operator=(const GetCallArgsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetCallArgsRequest(GetCallArgsRequest&& from) noexcept
    : GetCallArgsRequest() {
    *this = ::std::move(from);
  }

  inline GetCallArgsRequest& operator=(GetCallArgsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetCallArgsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCallArgsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCallArgsRequest*>(
               &_GetCallArgsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(GetCallArgsRequest* other);
  friend void swap(GetCallArgsRequest& a, GetCallArgsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetCallArgsRequest* New() const final {
    return CreateMaybeMessage<GetCallArgsRequest>(nullptr);
  }

  GetCallArgsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetCallArgsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetCallArgsRequest& from);
  void MergeFrom(const GetCallArgsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCallArgsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.GetCallArgsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TxInput :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.TxInput) */ {
 public:
  TxInput();
  virtual ~TxInput();

  TxInput(const TxInput& from);

  inline TxInput& operator=(const TxInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxInput(TxInput&& from) noexcept
    : TxInput() {
    *this = ::std::move(from);
  }

  inline TxInput& operator=(TxInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxInput* internal_default_instance() {
    return reinterpret_cast<const TxInput*>(
               &_TxInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(TxInput* other);
  friend void swap(TxInput& a, TxInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxInput* New() const final {
    return CreateMaybeMessage<TxInput>(nullptr);
  }

  TxInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxInput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxInput& from);
  void MergeFrom(const TxInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ref_txid = 1;
  void clear_ref_txid();
  static const int kRefTxidFieldNumber = 1;
  const ::std::string& ref_txid() const;
  void set_ref_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_txid(::std::string&& value);
  #endif
  void set_ref_txid(const char* value);
  void set_ref_txid(const char* value, size_t size);
  ::std::string* mutable_ref_txid();
  ::std::string* release_ref_txid();
  void set_allocated_ref_txid(::std::string* ref_txid);

  // bytes from_addr = 5;
  void clear_from_addr();
  static const int kFromAddrFieldNumber = 5;
  const ::std::string& from_addr() const;
  void set_from_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_from_addr(::std::string&& value);
  #endif
  void set_from_addr(const char* value);
  void set_from_addr(const void* value, size_t size);
  ::std::string* mutable_from_addr();
  ::std::string* release_from_addr();
  void set_allocated_from_addr(::std::string* from_addr);

  // string amount = 6;
  void clear_amount();
  static const int kAmountFieldNumber = 6;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // int32 ref_offset = 2;
  void clear_ref_offset();
  static const int kRefOffsetFieldNumber = 2;
  ::google::protobuf::int32 ref_offset() const;
  void set_ref_offset(::google::protobuf::int32 value);

  // int64 frozen_height = 7;
  void clear_frozen_height();
  static const int kFrozenHeightFieldNumber = 7;
  ::google::protobuf::int64 frozen_height() const;
  void set_frozen_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.TxInput)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ref_txid_;
  ::google::protobuf::internal::ArenaStringPtr from_addr_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::int32 ref_offset_;
  ::google::protobuf::int64 frozen_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class TxOutput :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.TxOutput) */ {
 public:
  TxOutput();
  virtual ~TxOutput();

  TxOutput(const TxOutput& from);

  inline TxOutput& operator=(const TxOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxOutput(TxOutput&& from) noexcept
    : TxOutput() {
    *this = ::std::move(from);
  }

  inline TxOutput& operator=(TxOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TxOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxOutput* internal_default_instance() {
    return reinterpret_cast<const TxOutput*>(
               &_TxOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(TxOutput* other);
  friend void swap(TxOutput& a, TxOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxOutput* New() const final {
    return CreateMaybeMessage<TxOutput>(nullptr);
  }

  TxOutput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxOutput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TxOutput& from);
  void MergeFrom(const TxOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string amount = 1;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // bytes to_addr = 2;
  void clear_to_addr();
  static const int kToAddrFieldNumber = 2;
  const ::std::string& to_addr() const;
  void set_to_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_to_addr(::std::string&& value);
  #endif
  void set_to_addr(const char* value);
  void set_to_addr(const void* value, size_t size);
  ::std::string* mutable_to_addr();
  ::std::string* release_to_addr();
  void set_allocated_to_addr(::std::string* to_addr);

  // int64 frozen_height = 4;
  void clear_frozen_height();
  static const int kFrozenHeightFieldNumber = 4;
  ::google::protobuf::int64 frozen_height() const;
  void set_frozen_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.TxOutput)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::internal::ArenaStringPtr to_addr_;
  ::google::protobuf::int64 frozen_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class Transaction :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xchain.contract.sdk.TxInput tx_inputs = 3;
  int tx_inputs_size() const;
  void clear_tx_inputs();
  static const int kTxInputsFieldNumber = 3;
  ::xchain::contract::sdk::TxInput* mutable_tx_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxInput >*
      mutable_tx_inputs();
  const ::xchain::contract::sdk::TxInput& tx_inputs(int index) const;
  ::xchain::contract::sdk::TxInput* add_tx_inputs();
  const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxInput >&
      tx_inputs() const;

  // repeated .xchain.contract.sdk.TxOutput tx_outputs = 4;
  int tx_outputs_size() const;
  void clear_tx_outputs();
  static const int kTxOutputsFieldNumber = 4;
  ::xchain::contract::sdk::TxOutput* mutable_tx_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxOutput >*
      mutable_tx_outputs();
  const ::xchain::contract::sdk::TxOutput& tx_outputs(int index) const;
  ::xchain::contract::sdk::TxOutput* add_tx_outputs();
  const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxOutput >&
      tx_outputs() const;

  // repeated string auth_require = 27;
  int auth_require_size() const;
  void clear_auth_require();
  static const int kAuthRequireFieldNumber = 27;
  const ::std::string& auth_require(int index) const;
  ::std::string* mutable_auth_require(int index);
  void set_auth_require(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_auth_require(int index, ::std::string&& value);
  #endif
  void set_auth_require(int index, const char* value);
  void set_auth_require(int index, const char* value, size_t size);
  ::std::string* add_auth_require();
  void add_auth_require(const ::std::string& value);
  #if LANG_CXX11
  void add_auth_require(::std::string&& value);
  #endif
  void add_auth_require(const char* value);
  void add_auth_require(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& auth_require() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_auth_require();

  // string txid = 1;
  void clear_txid();
  static const int kTxidFieldNumber = 1;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const char* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // string blockid = 2;
  void clear_blockid();
  static const int kBlockidFieldNumber = 2;
  const ::std::string& blockid() const;
  void set_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockid(::std::string&& value);
  #endif
  void set_blockid(const char* value);
  void set_blockid(const char* value, size_t size);
  ::std::string* mutable_blockid();
  ::std::string* release_blockid();
  void set_allocated_blockid(::std::string* blockid);

  // bytes desc = 6;
  void clear_desc();
  static const int kDescFieldNumber = 6;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // string initiator = 26;
  void clear_initiator();
  static const int kInitiatorFieldNumber = 26;
  const ::std::string& initiator() const;
  void set_initiator(const ::std::string& value);
  #if LANG_CXX11
  void set_initiator(::std::string&& value);
  #endif
  void set_initiator(const char* value);
  void set_initiator(const char* value, size_t size);
  ::std::string* mutable_initiator();
  ::std::string* release_initiator();
  void set_allocated_initiator(::std::string* initiator);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.Transaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxInput > tx_inputs_;
  ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxOutput > tx_outputs_;
  ::google::protobuf::RepeatedPtrField<::std::string> auth_require_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::google::protobuf::internal::ArenaStringPtr blockid_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr initiator_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class Block :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string txids = 11;
  int txids_size() const;
  void clear_txids();
  static const int kTxidsFieldNumber = 11;
  const ::std::string& txids(int index) const;
  ::std::string* mutable_txids(int index);
  void set_txids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_txids(int index, ::std::string&& value);
  #endif
  void set_txids(int index, const char* value);
  void set_txids(int index, const char* value, size_t size);
  ::std::string* add_txids();
  void add_txids(const ::std::string& value);
  #if LANG_CXX11
  void add_txids(::std::string&& value);
  #endif
  void add_txids(const char* value);
  void add_txids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& txids() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_txids();

  // string blockid = 3;
  void clear_blockid();
  static const int kBlockidFieldNumber = 3;
  const ::std::string& blockid() const;
  void set_blockid(const ::std::string& value);
  #if LANG_CXX11
  void set_blockid(::std::string&& value);
  #endif
  void set_blockid(const char* value);
  void set_blockid(const char* value, size_t size);
  ::std::string* mutable_blockid();
  ::std::string* release_blockid();
  void set_allocated_blockid(::std::string* blockid);

  // string pre_hash = 4;
  void clear_pre_hash();
  static const int kPreHashFieldNumber = 4;
  const ::std::string& pre_hash() const;
  void set_pre_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_pre_hash(::std::string&& value);
  #endif
  void set_pre_hash(const char* value);
  void set_pre_hash(const char* value, size_t size);
  ::std::string* mutable_pre_hash();
  ::std::string* release_pre_hash();
  void set_allocated_pre_hash(::std::string* pre_hash);

  // bytes proposer = 5;
  void clear_proposer();
  static const int kProposerFieldNumber = 5;
  const ::std::string& proposer() const;
  void set_proposer(const ::std::string& value);
  #if LANG_CXX11
  void set_proposer(::std::string&& value);
  #endif
  void set_proposer(const char* value);
  void set_proposer(const void* value, size_t size);
  ::std::string* mutable_proposer();
  ::std::string* release_proposer();
  void set_allocated_proposer(::std::string* proposer);

  // string sign = 6;
  void clear_sign();
  static const int kSignFieldNumber = 6;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const char* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // bytes pubkey = 7;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 7;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // string next_hash = 15;
  void clear_next_hash();
  static const int kNextHashFieldNumber = 15;
  const ::std::string& next_hash() const;
  void set_next_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_next_hash(::std::string&& value);
  #endif
  void set_next_hash(const char* value);
  void set_next_hash(const char* value, size_t size);
  ::std::string* mutable_next_hash();
  ::std::string* release_next_hash();
  void set_allocated_next_hash(::std::string* next_hash);

  // int64 height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int32 tx_count = 12;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 12;
  ::google::protobuf::int32 tx_count() const;
  void set_tx_count(::google::protobuf::int32 value);

  // bool in_trunk = 14;
  void clear_in_trunk();
  static const int kInTrunkFieldNumber = 14;
  bool in_trunk() const;
  void set_in_trunk(bool value);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.Block)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> txids_;
  ::google::protobuf::internal::ArenaStringPtr blockid_;
  ::google::protobuf::internal::ArenaStringPtr pre_hash_;
  ::google::protobuf::internal::ArenaStringPtr proposer_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr next_hash_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int32 tx_count_;
  bool in_trunk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAddressesRequest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.GetAccountAddressesRequest) */ {
 public:
  GetAccountAddressesRequest();
  virtual ~GetAccountAddressesRequest();

  GetAccountAddressesRequest(const GetAccountAddressesRequest& from);

  inline GetAccountAddressesRequest& operator=(const GetAccountAddressesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountAddressesRequest(GetAccountAddressesRequest&& from) noexcept
    : GetAccountAddressesRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAddressesRequest& operator=(GetAccountAddressesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetAccountAddressesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountAddressesRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAddressesRequest*>(
               &_GetAccountAddressesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GetAccountAddressesRequest* other);
  friend void swap(GetAccountAddressesRequest& a, GetAccountAddressesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAddressesRequest* New() const final {
    return CreateMaybeMessage<GetAccountAddressesRequest>(nullptr);
  }

  GetAccountAddressesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAddressesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetAccountAddressesRequest& from);
  void MergeFrom(const GetAccountAddressesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAccountAddressesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 2;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // .xchain.contract.sdk.SyscallHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xchain::contract::sdk::SyscallHeader& header() const;
  ::xchain::contract::sdk::SyscallHeader* release_header();
  ::xchain::contract::sdk::SyscallHeader* mutable_header();
  void set_allocated_header(::xchain::contract::sdk::SyscallHeader* header);

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.GetAccountAddressesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::xchain::contract::sdk::SyscallHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAddressesResponse :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:xchain.contract.sdk.GetAccountAddressesResponse) */ {
 public:
  GetAccountAddressesResponse();
  virtual ~GetAccountAddressesResponse();

  GetAccountAddressesResponse(const GetAccountAddressesResponse& from);

  inline GetAccountAddressesResponse& operator=(const GetAccountAddressesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountAddressesResponse(GetAccountAddressesResponse&& from) noexcept
    : GetAccountAddressesResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountAddressesResponse& operator=(GetAccountAddressesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetAccountAddressesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountAddressesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountAddressesResponse*>(
               &_GetAccountAddressesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(GetAccountAddressesResponse* other);
  friend void swap(GetAccountAddressesResponse& a, GetAccountAddressesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAddressesResponse* New() const final {
    return CreateMaybeMessage<GetAccountAddressesResponse>(nullptr);
  }

  GetAccountAddressesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAddressesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetAccountAddressesResponse& from);
  void MergeFrom(const GetAccountAddressesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAccountAddressesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string addresses = 1;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 1;
  const ::std::string& addresses(int index) const;
  ::std::string* mutable_addresses(int index);
  void set_addresses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addresses(int index, ::std::string&& value);
  #endif
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  ::std::string* add_addresses();
  void add_addresses(const ::std::string& value);
  #if LANG_CXX11
  void add_addresses(::std::string&& value);
  #endif
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& addresses() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_addresses();

  // @@protoc_insertion_point(class_scope:xchain.contract.sdk.GetAccountAddressesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> addresses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_contract_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// NativeCallRequest

// int64 ctxid = 1;
inline void NativeCallRequest::clear_ctxid() {
  ctxid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 NativeCallRequest::ctxid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.NativeCallRequest.ctxid)
  return ctxid_;
}
inline void NativeCallRequest::set_ctxid(::google::protobuf::int64 value) {
  
  ctxid_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.NativeCallRequest.ctxid)
}

// -------------------------------------------------------------------

// NativeCallResponse

// -------------------------------------------------------------------

// ArgPair

// string key = 1;
inline void ArgPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArgPair::key() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ArgPair.key)
  return key_.GetNoArena();
}
inline void ArgPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.ArgPair.key)
}
#if LANG_CXX11
inline void ArgPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.ArgPair.key)
}
#endif
inline void ArgPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.ArgPair.key)
}
inline void ArgPair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.ArgPair.key)
}
inline ::std::string* ArgPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ArgPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArgPair::release_key() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ArgPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArgPair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ArgPair.key)
}

// bytes value = 2;
inline void ArgPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArgPair::value() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ArgPair.value)
  return value_.GetNoArena();
}
inline void ArgPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.ArgPair.value)
}
#if LANG_CXX11
inline void ArgPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.ArgPair.value)
}
#endif
inline void ArgPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.ArgPair.value)
}
inline void ArgPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.ArgPair.value)
}
inline ::std::string* ArgPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ArgPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArgPair::release_value() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ArgPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArgPair::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ArgPair.value)
}

// -------------------------------------------------------------------

// CallArgs

// string method = 1;
inline void CallArgs::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallArgs::method() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.CallArgs.method)
  return method_.GetNoArena();
}
inline void CallArgs::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.CallArgs.method)
}
#if LANG_CXX11
inline void CallArgs::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.CallArgs.method)
}
#endif
inline void CallArgs::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.CallArgs.method)
}
inline void CallArgs::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.CallArgs.method)
}
inline ::std::string* CallArgs::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.CallArgs.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallArgs::release_method() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.CallArgs.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallArgs::set_allocated_method(::std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.CallArgs.method)
}

// repeated .xchain.contract.sdk.ArgPair args = 2;
inline int CallArgs::args_size() const {
  return args_.size();
}
inline void CallArgs::clear_args() {
  args_.Clear();
}
inline ::xchain::contract::sdk::ArgPair* CallArgs::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.CallArgs.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >*
CallArgs::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.CallArgs.args)
  return &args_;
}
inline const ::xchain::contract::sdk::ArgPair& CallArgs::args(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.CallArgs.args)
  return args_.Get(index);
}
inline ::xchain::contract::sdk::ArgPair* CallArgs::add_args() {
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.CallArgs.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >&
CallArgs::args() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.CallArgs.args)
  return args_;
}

// string initiator = 3;
inline void CallArgs::clear_initiator() {
  initiator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallArgs::initiator() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.CallArgs.initiator)
  return initiator_.GetNoArena();
}
inline void CallArgs::set_initiator(const ::std::string& value) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.CallArgs.initiator)
}
#if LANG_CXX11
inline void CallArgs::set_initiator(::std::string&& value) {
  
  initiator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.CallArgs.initiator)
}
#endif
inline void CallArgs::set_initiator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.CallArgs.initiator)
}
inline void CallArgs::set_initiator(const char* value, size_t size) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.CallArgs.initiator)
}
inline ::std::string* CallArgs::mutable_initiator() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.CallArgs.initiator)
  return initiator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallArgs::release_initiator() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.CallArgs.initiator)
  
  return initiator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallArgs::set_allocated_initiator(::std::string* initiator) {
  if (initiator != nullptr) {
    
  } else {
    
  }
  initiator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), initiator);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.CallArgs.initiator)
}

// repeated string auth_require = 4;
inline int CallArgs::auth_require_size() const {
  return auth_require_.size();
}
inline void CallArgs::clear_auth_require() {
  auth_require_.Clear();
}
inline const ::std::string& CallArgs::auth_require(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.CallArgs.auth_require)
  return auth_require_.Get(index);
}
inline ::std::string* CallArgs::mutable_auth_require(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.CallArgs.auth_require)
  return auth_require_.Mutable(index);
}
inline void CallArgs::set_auth_require(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.CallArgs.auth_require)
  auth_require_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CallArgs::set_auth_require(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.CallArgs.auth_require)
  auth_require_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CallArgs::set_auth_require(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.CallArgs.auth_require)
}
inline void CallArgs::set_auth_require(int index, const char* value, size_t size) {
  auth_require_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.CallArgs.auth_require)
}
inline ::std::string* CallArgs::add_auth_require() {
  // @@protoc_insertion_point(field_add_mutable:xchain.contract.sdk.CallArgs.auth_require)
  return auth_require_.Add();
}
inline void CallArgs::add_auth_require(const ::std::string& value) {
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.CallArgs.auth_require)
}
#if LANG_CXX11
inline void CallArgs::add_auth_require(::std::string&& value) {
  auth_require_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.CallArgs.auth_require)
}
#endif
inline void CallArgs::add_auth_require(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xchain.contract.sdk.CallArgs.auth_require)
}
inline void CallArgs::add_auth_require(const char* value, size_t size) {
  auth_require_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xchain.contract.sdk.CallArgs.auth_require)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CallArgs::auth_require() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.CallArgs.auth_require)
  return auth_require_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
CallArgs::mutable_auth_require() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.CallArgs.auth_require)
  return &auth_require_;
}

// string transfer_amount = 5;
inline void CallArgs::clear_transfer_amount() {
  transfer_amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallArgs::transfer_amount() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.CallArgs.transfer_amount)
  return transfer_amount_.GetNoArena();
}
inline void CallArgs::set_transfer_amount(const ::std::string& value) {
  
  transfer_amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.CallArgs.transfer_amount)
}
#if LANG_CXX11
inline void CallArgs::set_transfer_amount(::std::string&& value) {
  
  transfer_amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.CallArgs.transfer_amount)
}
#endif
inline void CallArgs::set_transfer_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transfer_amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.CallArgs.transfer_amount)
}
inline void CallArgs::set_transfer_amount(const char* value, size_t size) {
  
  transfer_amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.CallArgs.transfer_amount)
}
inline ::std::string* CallArgs::mutable_transfer_amount() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.CallArgs.transfer_amount)
  return transfer_amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallArgs::release_transfer_amount() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.CallArgs.transfer_amount)
  
  return transfer_amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallArgs::set_allocated_transfer_amount(::std::string* transfer_amount) {
  if (transfer_amount != nullptr) {
    
  } else {
    
  }
  transfer_amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_amount);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.CallArgs.transfer_amount)
}

// -------------------------------------------------------------------

// SyscallHeader

// int64 ctxid = 1;
inline void SyscallHeader::clear_ctxid() {
  ctxid_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SyscallHeader::ctxid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.SyscallHeader.ctxid)
  return ctxid_;
}
inline void SyscallHeader::set_ctxid(::google::protobuf::int64 value) {
  
  ctxid_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.SyscallHeader.ctxid)
}

// -------------------------------------------------------------------

// PutRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool PutRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& PutRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.PutRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* PutRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.PutRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* PutRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.PutRequest.header)
  return header_;
}
inline void PutRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.PutRequest.header)
}

// bytes key = 2;
inline void PutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.PutRequest.key)
  return key_.GetNoArena();
}
inline void PutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.PutRequest.key)
}
#if LANG_CXX11
inline void PutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.PutRequest.key)
}
#endif
inline void PutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.PutRequest.key)
}
inline void PutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.PutRequest.key)
}
inline ::std::string* PutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.PutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.PutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.PutRequest.key)
}

// bytes value = 3;
inline void PutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.PutRequest.value)
  return value_.GetNoArena();
}
inline void PutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.PutRequest.value)
}
#if LANG_CXX11
inline void PutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.PutRequest.value)
}
#endif
inline void PutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.PutRequest.value)
}
inline void PutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.PutRequest.value)
}
inline ::std::string* PutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.PutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.PutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PutRequest::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// -------------------------------------------------------------------

// GetRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool GetRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& GetRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* GetRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* GetRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetRequest.header)
  return header_;
}
inline void GetRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetRequest.header)
}

// bytes key = 2;
inline void GetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetRequest.key)
  return key_.GetNoArena();
}
inline void GetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.GetRequest.key)
}
#if LANG_CXX11
inline void GetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.GetRequest.key)
}
#endif
inline void GetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.GetRequest.key)
}
inline void GetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.GetRequest.key)
}
inline ::std::string* GetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetRequest.key)
}

// -------------------------------------------------------------------

// GetResponse

// bytes value = 1;
inline void GetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetResponse.value)
  return value_.GetNoArena();
}
inline void GetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.GetResponse.value)
}
#if LANG_CXX11
inline void GetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.GetResponse.value)
}
#endif
inline void GetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.GetResponse.value)
}
inline void GetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.GetResponse.value)
}
inline ::std::string* GetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetResponse::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetResponse.value)
}

// -------------------------------------------------------------------

// DeleteRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool DeleteRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void DeleteRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& DeleteRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.DeleteRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* DeleteRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.DeleteRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* DeleteRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.DeleteRequest.header)
  return header_;
}
inline void DeleteRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.DeleteRequest.header)
}

// bytes key = 2;
inline void DeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.DeleteRequest.key)
  return key_.GetNoArena();
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.DeleteRequest.key)
}
#if LANG_CXX11
inline void DeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.DeleteRequest.key)
}
#endif
inline void DeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.DeleteRequest.key)
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.DeleteRequest.key)
}
inline ::std::string* DeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.DeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.DeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.DeleteRequest.key)
}

// -------------------------------------------------------------------

// DeleteResponse

// -------------------------------------------------------------------

// IteratorRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool IteratorRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void IteratorRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& IteratorRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* IteratorRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.IteratorRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* IteratorRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorRequest.header)
  return header_;
}
inline void IteratorRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.IteratorRequest.header)
}

// bytes start = 2;
inline void IteratorRequest::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IteratorRequest::start() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorRequest.start)
  return start_.GetNoArena();
}
inline void IteratorRequest::set_start(const ::std::string& value) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.IteratorRequest.start)
}
#if LANG_CXX11
inline void IteratorRequest::set_start(::std::string&& value) {
  
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.IteratorRequest.start)
}
#endif
inline void IteratorRequest::set_start(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.IteratorRequest.start)
}
inline void IteratorRequest::set_start(const void* value, size_t size) {
  
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.IteratorRequest.start)
}
inline ::std::string* IteratorRequest::mutable_start() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorRequest.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IteratorRequest::release_start() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.IteratorRequest.start)
  
  return start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IteratorRequest::set_allocated_start(::std::string* start) {
  if (start != nullptr) {
    
  } else {
    
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.IteratorRequest.start)
}

// bytes limit = 3;
inline void IteratorRequest::clear_limit() {
  limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IteratorRequest::limit() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorRequest.limit)
  return limit_.GetNoArena();
}
inline void IteratorRequest::set_limit(const ::std::string& value) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.IteratorRequest.limit)
}
#if LANG_CXX11
inline void IteratorRequest::set_limit(::std::string&& value) {
  
  limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.IteratorRequest.limit)
}
#endif
inline void IteratorRequest::set_limit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.IteratorRequest.limit)
}
inline void IteratorRequest::set_limit(const void* value, size_t size) {
  
  limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.IteratorRequest.limit)
}
inline ::std::string* IteratorRequest::mutable_limit() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorRequest.limit)
  return limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IteratorRequest::release_limit() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.IteratorRequest.limit)
  
  return limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IteratorRequest::set_allocated_limit(::std::string* limit) {
  if (limit != nullptr) {
    
  } else {
    
  }
  limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), limit);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.IteratorRequest.limit)
}

// int32 cap = 4;
inline void IteratorRequest::clear_cap() {
  cap_ = 0;
}
inline ::google::protobuf::int32 IteratorRequest::cap() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorRequest.cap)
  return cap_;
}
inline void IteratorRequest::set_cap(::google::protobuf::int32 value) {
  
  cap_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.IteratorRequest.cap)
}

// -------------------------------------------------------------------

// IteratorItem

// bytes key = 1;
inline void IteratorItem::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IteratorItem::key() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorItem.key)
  return key_.GetNoArena();
}
inline void IteratorItem::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.IteratorItem.key)
}
#if LANG_CXX11
inline void IteratorItem::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.IteratorItem.key)
}
#endif
inline void IteratorItem::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.IteratorItem.key)
}
inline void IteratorItem::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.IteratorItem.key)
}
inline ::std::string* IteratorItem::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorItem.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IteratorItem::release_key() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.IteratorItem.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IteratorItem::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.IteratorItem.key)
}

// bytes value = 2;
inline void IteratorItem::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IteratorItem::value() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorItem.value)
  return value_.GetNoArena();
}
inline void IteratorItem::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.IteratorItem.value)
}
#if LANG_CXX11
inline void IteratorItem::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.IteratorItem.value)
}
#endif
inline void IteratorItem::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.IteratorItem.value)
}
inline void IteratorItem::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.IteratorItem.value)
}
inline ::std::string* IteratorItem::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorItem.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IteratorItem::release_value() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.IteratorItem.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IteratorItem::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.IteratorItem.value)
}

// -------------------------------------------------------------------

// IteratorResponse

// repeated .xchain.contract.sdk.IteratorItem items = 1;
inline int IteratorResponse::items_size() const {
  return items_.size();
}
inline void IteratorResponse::clear_items() {
  items_.Clear();
}
inline ::xchain::contract::sdk::IteratorItem* IteratorResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.IteratorResponse.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::IteratorItem >*
IteratorResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.IteratorResponse.items)
  return &items_;
}
inline const ::xchain::contract::sdk::IteratorItem& IteratorResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.IteratorResponse.items)
  return items_.Get(index);
}
inline ::xchain::contract::sdk::IteratorItem* IteratorResponse::add_items() {
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.IteratorResponse.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::IteratorItem >&
IteratorResponse::items() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.IteratorResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// QueryTxRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool QueryTxRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void QueryTxRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& QueryTxRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryTxRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* QueryTxRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryTxRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* QueryTxRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryTxRequest.header)
  return header_;
}
inline void QueryTxRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryTxRequest.header)
}

// string txid = 2;
inline void QueryTxRequest::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryTxRequest::txid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryTxRequest.txid)
  return txid_.GetNoArena();
}
inline void QueryTxRequest::set_txid(const ::std::string& value) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.QueryTxRequest.txid)
}
#if LANG_CXX11
inline void QueryTxRequest::set_txid(::std::string&& value) {
  
  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.QueryTxRequest.txid)
}
#endif
inline void QueryTxRequest::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.QueryTxRequest.txid)
}
inline void QueryTxRequest::set_txid(const char* value, size_t size) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.QueryTxRequest.txid)
}
inline ::std::string* QueryTxRequest::mutable_txid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryTxRequest.txid)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryTxRequest::release_txid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryTxRequest.txid)
  
  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryTxRequest::set_allocated_txid(::std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryTxRequest.txid)
}

// -------------------------------------------------------------------

// QueryTxResponse

// .xchain.contract.sdk.Transaction tx = 1;
inline bool QueryTxResponse::has_tx() const {
  return this != internal_default_instance() && tx_ != nullptr;
}
inline void QueryTxResponse::clear_tx() {
  if (GetArenaNoVirtual() == nullptr && tx_ != nullptr) {
    delete tx_;
  }
  tx_ = nullptr;
}
inline const ::xchain::contract::sdk::Transaction& QueryTxResponse::tx() const {
  const ::xchain::contract::sdk::Transaction* p = tx_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryTxResponse.tx)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::Transaction*>(
      &::xchain::contract::sdk::_Transaction_default_instance_);
}
inline ::xchain::contract::sdk::Transaction* QueryTxResponse::release_tx() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryTxResponse.tx)
  
  ::xchain::contract::sdk::Transaction* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::Transaction* QueryTxResponse::mutable_tx() {
  
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::Transaction>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryTxResponse.tx)
  return tx_;
}
inline void QueryTxResponse::set_allocated_tx(::xchain::contract::sdk::Transaction* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    
  } else {
    
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryTxResponse.tx)
}

// -------------------------------------------------------------------

// QueryBlockRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool QueryBlockRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void QueryBlockRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& QueryBlockRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryBlockRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* QueryBlockRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryBlockRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* QueryBlockRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryBlockRequest.header)
  return header_;
}
inline void QueryBlockRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryBlockRequest.header)
}

// string blockid = 2;
inline void QueryBlockRequest::clear_blockid() {
  blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& QueryBlockRequest::blockid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryBlockRequest.blockid)
  return blockid_.GetNoArena();
}
inline void QueryBlockRequest::set_blockid(const ::std::string& value) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.QueryBlockRequest.blockid)
}
#if LANG_CXX11
inline void QueryBlockRequest::set_blockid(::std::string&& value) {
  
  blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.QueryBlockRequest.blockid)
}
#endif
inline void QueryBlockRequest::set_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.QueryBlockRequest.blockid)
}
inline void QueryBlockRequest::set_blockid(const char* value, size_t size) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.QueryBlockRequest.blockid)
}
inline ::std::string* QueryBlockRequest::mutable_blockid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryBlockRequest.blockid)
  return blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryBlockRequest::release_blockid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryBlockRequest.blockid)
  
  return blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryBlockRequest::set_allocated_blockid(::std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryBlockRequest.blockid)
}

// -------------------------------------------------------------------

// QueryBlockResponse

// .xchain.contract.sdk.Block block = 1;
inline bool QueryBlockResponse::has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline void QueryBlockResponse::clear_block() {
  if (GetArenaNoVirtual() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::xchain::contract::sdk::Block& QueryBlockResponse::block() const {
  const ::xchain::contract::sdk::Block* p = block_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.QueryBlockResponse.block)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::Block*>(
      &::xchain::contract::sdk::_Block_default_instance_);
}
inline ::xchain::contract::sdk::Block* QueryBlockResponse::release_block() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.QueryBlockResponse.block)
  
  ::xchain::contract::sdk::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::Block* QueryBlockResponse::mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.QueryBlockResponse.block)
  return block_;
}
inline void QueryBlockResponse::set_allocated_block(::xchain::contract::sdk::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.QueryBlockResponse.block)
}

// -------------------------------------------------------------------

// TransferRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool TransferRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TransferRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& TransferRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TransferRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* TransferRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TransferRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* TransferRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TransferRequest.header)
  return header_;
}
inline void TransferRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TransferRequest.header)
}

// string from = 2;
inline void TransferRequest::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::from() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TransferRequest.from)
  return from_.GetNoArena();
}
inline void TransferRequest::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TransferRequest.from)
}
#if LANG_CXX11
inline void TransferRequest::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TransferRequest.from)
}
#endif
inline void TransferRequest::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TransferRequest.from)
}
inline void TransferRequest::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TransferRequest.from)
}
inline ::std::string* TransferRequest::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TransferRequest.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_from() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TransferRequest.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_from(::std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TransferRequest.from)
}

// string to = 3;
inline void TransferRequest::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::to() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TransferRequest.to)
  return to_.GetNoArena();
}
inline void TransferRequest::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TransferRequest.to)
}
#if LANG_CXX11
inline void TransferRequest::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TransferRequest.to)
}
#endif
inline void TransferRequest::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TransferRequest.to)
}
inline void TransferRequest::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TransferRequest.to)
}
inline ::std::string* TransferRequest::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TransferRequest.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_to() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TransferRequest.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_to(::std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TransferRequest.to)
}

// string amount = 4;
inline void TransferRequest::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferRequest::amount() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TransferRequest.amount)
  return amount_.GetNoArena();
}
inline void TransferRequest::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TransferRequest.amount)
}
#if LANG_CXX11
inline void TransferRequest::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TransferRequest.amount)
}
#endif
inline void TransferRequest::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TransferRequest.amount)
}
inline void TransferRequest::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TransferRequest.amount)
}
inline ::std::string* TransferRequest::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TransferRequest.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferRequest::release_amount() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TransferRequest.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferRequest::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TransferRequest.amount)
}

// -------------------------------------------------------------------

// TransferResponse

// -------------------------------------------------------------------

// ContractCallRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool ContractCallRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ContractCallRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& ContractCallRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* ContractCallRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ContractCallRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* ContractCallRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallRequest.header)
  return header_;
}
inline void ContractCallRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ContractCallRequest.header)
}

// string module = 2;
inline void ContractCallRequest::clear_module() {
  module_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::module() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallRequest.module)
  return module_.GetNoArena();
}
inline void ContractCallRequest::set_module(const ::std::string& value) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.ContractCallRequest.module)
}
#if LANG_CXX11
inline void ContractCallRequest::set_module(::std::string&& value) {
  
  module_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.ContractCallRequest.module)
}
#endif
inline void ContractCallRequest::set_module(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.ContractCallRequest.module)
}
inline void ContractCallRequest::set_module(const char* value, size_t size) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.ContractCallRequest.module)
}
inline ::std::string* ContractCallRequest::mutable_module() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallRequest.module)
  return module_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_module() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ContractCallRequest.module)
  
  return module_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_module(::std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  module_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ContractCallRequest.module)
}

// string contract = 3;
inline void ContractCallRequest::clear_contract() {
  contract_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::contract() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallRequest.contract)
  return contract_.GetNoArena();
}
inline void ContractCallRequest::set_contract(const ::std::string& value) {
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.ContractCallRequest.contract)
}
#if LANG_CXX11
inline void ContractCallRequest::set_contract(::std::string&& value) {
  
  contract_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.ContractCallRequest.contract)
}
#endif
inline void ContractCallRequest::set_contract(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.ContractCallRequest.contract)
}
inline void ContractCallRequest::set_contract(const char* value, size_t size) {
  
  contract_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.ContractCallRequest.contract)
}
inline ::std::string* ContractCallRequest::mutable_contract() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallRequest.contract)
  return contract_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_contract() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ContractCallRequest.contract)
  
  return contract_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_contract(::std::string* contract) {
  if (contract != nullptr) {
    
  } else {
    
  }
  contract_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ContractCallRequest.contract)
}

// string method = 4;
inline void ContractCallRequest::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractCallRequest::method() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallRequest.method)
  return method_.GetNoArena();
}
inline void ContractCallRequest::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.ContractCallRequest.method)
}
#if LANG_CXX11
inline void ContractCallRequest::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.ContractCallRequest.method)
}
#endif
inline void ContractCallRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.ContractCallRequest.method)
}
inline void ContractCallRequest::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.ContractCallRequest.method)
}
inline ::std::string* ContractCallRequest::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallRequest.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractCallRequest::release_method() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ContractCallRequest.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractCallRequest::set_allocated_method(::std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ContractCallRequest.method)
}

// repeated .xchain.contract.sdk.ArgPair args = 5;
inline int ContractCallRequest::args_size() const {
  return args_.size();
}
inline void ContractCallRequest::clear_args() {
  args_.Clear();
}
inline ::xchain::contract::sdk::ArgPair* ContractCallRequest::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallRequest.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >*
ContractCallRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.ContractCallRequest.args)
  return &args_;
}
inline const ::xchain::contract::sdk::ArgPair& ContractCallRequest::args(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallRequest.args)
  return args_.Get(index);
}
inline ::xchain::contract::sdk::ArgPair* ContractCallRequest::add_args() {
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.ContractCallRequest.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::ArgPair >&
ContractCallRequest::args() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.ContractCallRequest.args)
  return args_;
}

// -------------------------------------------------------------------

// ContractCallResponse

// .xchain.contract.sdk.Response response = 1;
inline bool ContractCallResponse::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline void ContractCallResponse::clear_response() {
  if (GetArenaNoVirtual() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::xchain::contract::sdk::Response& ContractCallResponse::response() const {
  const ::xchain::contract::sdk::Response* p = response_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.ContractCallResponse.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::Response*>(
      &::xchain::contract::sdk::_Response_default_instance_);
}
inline ::xchain::contract::sdk::Response* ContractCallResponse::release_response() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.ContractCallResponse.response)
  
  ::xchain::contract::sdk::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::Response* ContractCallResponse::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.ContractCallResponse.response)
  return response_;
}
inline void ContractCallResponse::set_allocated_response(::xchain::contract::sdk::Response* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.ContractCallResponse.response)
}

// -------------------------------------------------------------------

// Response

// int32 status = 1;
inline void Response::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 Response::status() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Response.status)
  return status_;
}
inline void Response::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Response.status)
}

// string message = 2;
inline void Response::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::message() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Response.message)
  return message_.GetNoArena();
}
inline void Response::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Response.message)
}
#if LANG_CXX11
inline void Response::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Response.message)
}
#endif
inline void Response::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Response.message)
}
inline void Response::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Response.message)
}
inline ::std::string* Response::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Response.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_message() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Response.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Response.message)
}

// bytes body = 3;
inline void Response::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::body() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Response.body)
  return body_.GetNoArena();
}
inline void Response::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Response.body)
}
#if LANG_CXX11
inline void Response::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Response.body)
}
#endif
inline void Response::set_body(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Response.body)
}
inline void Response::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Response.body)
}
inline ::std::string* Response::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Response.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_body() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Response.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_body(::std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Response.body)
}

// -------------------------------------------------------------------

// SetOutputRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool SetOutputRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void SetOutputRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& SetOutputRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.SetOutputRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* SetOutputRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.SetOutputRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* SetOutputRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.SetOutputRequest.header)
  return header_;
}
inline void SetOutputRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.SetOutputRequest.header)
}

// .xchain.contract.sdk.Response response = 2;
inline bool SetOutputRequest::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline void SetOutputRequest::clear_response() {
  if (GetArenaNoVirtual() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::xchain::contract::sdk::Response& SetOutputRequest::response() const {
  const ::xchain::contract::sdk::Response* p = response_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.SetOutputRequest.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::Response*>(
      &::xchain::contract::sdk::_Response_default_instance_);
}
inline ::xchain::contract::sdk::Response* SetOutputRequest::release_response() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.SetOutputRequest.response)
  
  ::xchain::contract::sdk::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::Response* SetOutputRequest::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.SetOutputRequest.response)
  return response_;
}
inline void SetOutputRequest::set_allocated_response(::xchain::contract::sdk::Response* response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.SetOutputRequest.response)
}

// -------------------------------------------------------------------

// SetOutputResponse

// -------------------------------------------------------------------

// GetCallArgsRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool GetCallArgsRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetCallArgsRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& GetCallArgsRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetCallArgsRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* GetCallArgsRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetCallArgsRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* GetCallArgsRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetCallArgsRequest.header)
  return header_;
}
inline void GetCallArgsRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetCallArgsRequest.header)
}

// -------------------------------------------------------------------

// TxInput

// string ref_txid = 1;
inline void TxInput::clear_ref_txid() {
  ref_txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::ref_txid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxInput.ref_txid)
  return ref_txid_.GetNoArena();
}
inline void TxInput::set_ref_txid(const ::std::string& value) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxInput.ref_txid)
}
#if LANG_CXX11
inline void TxInput::set_ref_txid(::std::string&& value) {
  
  ref_txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TxInput.ref_txid)
}
#endif
inline void TxInput::set_ref_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TxInput.ref_txid)
}
inline void TxInput::set_ref_txid(const char* value, size_t size) {
  
  ref_txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TxInput.ref_txid)
}
inline ::std::string* TxInput::mutable_ref_txid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TxInput.ref_txid)
  return ref_txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_ref_txid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TxInput.ref_txid)
  
  return ref_txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_ref_txid(::std::string* ref_txid) {
  if (ref_txid != nullptr) {
    
  } else {
    
  }
  ref_txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_txid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TxInput.ref_txid)
}

// int32 ref_offset = 2;
inline void TxInput::clear_ref_offset() {
  ref_offset_ = 0;
}
inline ::google::protobuf::int32 TxInput::ref_offset() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxInput.ref_offset)
  return ref_offset_;
}
inline void TxInput::set_ref_offset(::google::protobuf::int32 value) {
  
  ref_offset_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxInput.ref_offset)
}

// bytes from_addr = 5;
inline void TxInput::clear_from_addr() {
  from_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::from_addr() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxInput.from_addr)
  return from_addr_.GetNoArena();
}
inline void TxInput::set_from_addr(const ::std::string& value) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxInput.from_addr)
}
#if LANG_CXX11
inline void TxInput::set_from_addr(::std::string&& value) {
  
  from_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TxInput.from_addr)
}
#endif
inline void TxInput::set_from_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TxInput.from_addr)
}
inline void TxInput::set_from_addr(const void* value, size_t size) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TxInput.from_addr)
}
inline ::std::string* TxInput::mutable_from_addr() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TxInput.from_addr)
  return from_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_from_addr() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TxInput.from_addr)
  
  return from_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_from_addr(::std::string* from_addr) {
  if (from_addr != nullptr) {
    
  } else {
    
  }
  from_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_addr);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TxInput.from_addr)
}

// string amount = 6;
inline void TxInput::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxInput::amount() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxInput.amount)
  return amount_.GetNoArena();
}
inline void TxInput::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxInput.amount)
}
#if LANG_CXX11
inline void TxInput::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TxInput.amount)
}
#endif
inline void TxInput::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TxInput.amount)
}
inline void TxInput::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TxInput.amount)
}
inline ::std::string* TxInput::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TxInput.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInput::release_amount() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TxInput.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInput::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TxInput.amount)
}

// int64 frozen_height = 7;
inline void TxInput::clear_frozen_height() {
  frozen_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TxInput::frozen_height() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxInput.frozen_height)
  return frozen_height_;
}
inline void TxInput::set_frozen_height(::google::protobuf::int64 value) {
  
  frozen_height_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxInput.frozen_height)
}

// -------------------------------------------------------------------

// TxOutput

// string amount = 1;
inline void TxOutput::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutput::amount() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxOutput.amount)
  return amount_.GetNoArena();
}
inline void TxOutput::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxOutput.amount)
}
#if LANG_CXX11
inline void TxOutput::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TxOutput.amount)
}
#endif
inline void TxOutput::set_amount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TxOutput.amount)
}
inline void TxOutput::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TxOutput.amount)
}
inline ::std::string* TxOutput::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TxOutput.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutput::release_amount() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TxOutput.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutput::set_allocated_amount(::std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TxOutput.amount)
}

// bytes to_addr = 2;
inline void TxOutput::clear_to_addr() {
  to_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxOutput::to_addr() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxOutput.to_addr)
  return to_addr_.GetNoArena();
}
inline void TxOutput::set_to_addr(const ::std::string& value) {
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxOutput.to_addr)
}
#if LANG_CXX11
inline void TxOutput::set_to_addr(::std::string&& value) {
  
  to_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.TxOutput.to_addr)
}
#endif
inline void TxOutput::set_to_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.TxOutput.to_addr)
}
inline void TxOutput::set_to_addr(const void* value, size_t size) {
  
  to_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.TxOutput.to_addr)
}
inline ::std::string* TxOutput::mutable_to_addr() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.TxOutput.to_addr)
  return to_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutput::release_to_addr() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.TxOutput.to_addr)
  
  return to_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutput::set_allocated_to_addr(::std::string* to_addr) {
  if (to_addr != nullptr) {
    
  } else {
    
  }
  to_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_addr);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.TxOutput.to_addr)
}

// int64 frozen_height = 4;
inline void TxOutput::clear_frozen_height() {
  frozen_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TxOutput::frozen_height() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.TxOutput.frozen_height)
  return frozen_height_;
}
inline void TxOutput::set_frozen_height(::google::protobuf::int64 value) {
  
  frozen_height_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.TxOutput.frozen_height)
}

// -------------------------------------------------------------------

// Transaction

// string txid = 1;
inline void Transaction::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::txid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.txid)
  return txid_.GetNoArena();
}
inline void Transaction::set_txid(const ::std::string& value) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.txid)
}
#if LANG_CXX11
inline void Transaction::set_txid(::std::string&& value) {
  
  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Transaction.txid)
}
#endif
inline void Transaction::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Transaction.txid)
}
inline void Transaction::set_txid(const char* value, size_t size) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Transaction.txid)
}
inline ::std::string* Transaction::mutable_txid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.txid)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_txid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Transaction.txid)
  
  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_txid(::std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Transaction.txid)
}

// string blockid = 2;
inline void Transaction::clear_blockid() {
  blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::blockid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.blockid)
  return blockid_.GetNoArena();
}
inline void Transaction::set_blockid(const ::std::string& value) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.blockid)
}
#if LANG_CXX11
inline void Transaction::set_blockid(::std::string&& value) {
  
  blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Transaction.blockid)
}
#endif
inline void Transaction::set_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Transaction.blockid)
}
inline void Transaction::set_blockid(const char* value, size_t size) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Transaction.blockid)
}
inline ::std::string* Transaction::mutable_blockid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.blockid)
  return blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_blockid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Transaction.blockid)
  
  return blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_blockid(::std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Transaction.blockid)
}

// repeated .xchain.contract.sdk.TxInput tx_inputs = 3;
inline int Transaction::tx_inputs_size() const {
  return tx_inputs_.size();
}
inline void Transaction::clear_tx_inputs() {
  tx_inputs_.Clear();
}
inline ::xchain::contract::sdk::TxInput* Transaction::mutable_tx_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.tx_inputs)
  return tx_inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxInput >*
Transaction::mutable_tx_inputs() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.Transaction.tx_inputs)
  return &tx_inputs_;
}
inline const ::xchain::contract::sdk::TxInput& Transaction::tx_inputs(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.tx_inputs)
  return tx_inputs_.Get(index);
}
inline ::xchain::contract::sdk::TxInput* Transaction::add_tx_inputs() {
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Transaction.tx_inputs)
  return tx_inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxInput >&
Transaction::tx_inputs() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.Transaction.tx_inputs)
  return tx_inputs_;
}

// repeated .xchain.contract.sdk.TxOutput tx_outputs = 4;
inline int Transaction::tx_outputs_size() const {
  return tx_outputs_.size();
}
inline void Transaction::clear_tx_outputs() {
  tx_outputs_.Clear();
}
inline ::xchain::contract::sdk::TxOutput* Transaction::mutable_tx_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.tx_outputs)
  return tx_outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxOutput >*
Transaction::mutable_tx_outputs() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.Transaction.tx_outputs)
  return &tx_outputs_;
}
inline const ::xchain::contract::sdk::TxOutput& Transaction::tx_outputs(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.tx_outputs)
  return tx_outputs_.Get(index);
}
inline ::xchain::contract::sdk::TxOutput* Transaction::add_tx_outputs() {
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Transaction.tx_outputs)
  return tx_outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xchain::contract::sdk::TxOutput >&
Transaction::tx_outputs() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.Transaction.tx_outputs)
  return tx_outputs_;
}

// bytes desc = 6;
inline void Transaction::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::desc() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.desc)
  return desc_.GetNoArena();
}
inline void Transaction::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.desc)
}
#if LANG_CXX11
inline void Transaction::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Transaction.desc)
}
#endif
inline void Transaction::set_desc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Transaction.desc)
}
inline void Transaction::set_desc(const void* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Transaction.desc)
}
inline ::std::string* Transaction::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_desc() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Transaction.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_desc(::std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Transaction.desc)
}

// string initiator = 26;
inline void Transaction::clear_initiator() {
  initiator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::initiator() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.initiator)
  return initiator_.GetNoArena();
}
inline void Transaction::set_initiator(const ::std::string& value) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.initiator)
}
#if LANG_CXX11
inline void Transaction::set_initiator(::std::string&& value) {
  
  initiator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Transaction.initiator)
}
#endif
inline void Transaction::set_initiator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Transaction.initiator)
}
inline void Transaction::set_initiator(const char* value, size_t size) {
  
  initiator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Transaction.initiator)
}
inline ::std::string* Transaction::mutable_initiator() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.initiator)
  return initiator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_initiator() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Transaction.initiator)
  
  return initiator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_initiator(::std::string* initiator) {
  if (initiator != nullptr) {
    
  } else {
    
  }
  initiator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), initiator);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Transaction.initiator)
}

// repeated string auth_require = 27;
inline int Transaction::auth_require_size() const {
  return auth_require_.size();
}
inline void Transaction::clear_auth_require() {
  auth_require_.Clear();
}
inline const ::std::string& Transaction::auth_require(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Transaction.auth_require)
  return auth_require_.Get(index);
}
inline ::std::string* Transaction::mutable_auth_require(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Transaction.auth_require)
  return auth_require_.Mutable(index);
}
inline void Transaction::set_auth_require(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.auth_require)
  auth_require_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Transaction::set_auth_require(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Transaction.auth_require)
  auth_require_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Transaction::set_auth_require(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Transaction.auth_require)
}
inline void Transaction::set_auth_require(int index, const char* value, size_t size) {
  auth_require_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Transaction.auth_require)
}
inline ::std::string* Transaction::add_auth_require() {
  // @@protoc_insertion_point(field_add_mutable:xchain.contract.sdk.Transaction.auth_require)
  return auth_require_.Add();
}
inline void Transaction::add_auth_require(const ::std::string& value) {
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Transaction.auth_require)
}
#if LANG_CXX11
inline void Transaction::add_auth_require(::std::string&& value) {
  auth_require_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Transaction.auth_require)
}
#endif
inline void Transaction::add_auth_require(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  auth_require_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xchain.contract.sdk.Transaction.auth_require)
}
inline void Transaction::add_auth_require(const char* value, size_t size) {
  auth_require_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xchain.contract.sdk.Transaction.auth_require)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Transaction::auth_require() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.Transaction.auth_require)
  return auth_require_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Transaction::mutable_auth_require() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.Transaction.auth_require)
  return &auth_require_;
}

// -------------------------------------------------------------------

// Block

// string blockid = 3;
inline void Block::clear_blockid() {
  blockid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::blockid() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.blockid)
  return blockid_.GetNoArena();
}
inline void Block::set_blockid(const ::std::string& value) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.blockid)
}
#if LANG_CXX11
inline void Block::set_blockid(::std::string&& value) {
  
  blockid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.blockid)
}
#endif
inline void Block::set_blockid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.blockid)
}
inline void Block::set_blockid(const char* value, size_t size) {
  
  blockid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.blockid)
}
inline ::std::string* Block::mutable_blockid() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.blockid)
  return blockid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_blockid() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.blockid)
  
  return blockid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_blockid(::std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockid);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.blockid)
}

// string pre_hash = 4;
inline void Block::clear_pre_hash() {
  pre_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::pre_hash() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.pre_hash)
  return pre_hash_.GetNoArena();
}
inline void Block::set_pre_hash(const ::std::string& value) {
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.pre_hash)
}
#if LANG_CXX11
inline void Block::set_pre_hash(::std::string&& value) {
  
  pre_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.pre_hash)
}
#endif
inline void Block::set_pre_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.pre_hash)
}
inline void Block::set_pre_hash(const char* value, size_t size) {
  
  pre_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.pre_hash)
}
inline ::std::string* Block::mutable_pre_hash() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.pre_hash)
  return pre_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_pre_hash() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.pre_hash)
  
  return pre_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_pre_hash(::std::string* pre_hash) {
  if (pre_hash != nullptr) {
    
  } else {
    
  }
  pre_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pre_hash);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.pre_hash)
}

// bytes proposer = 5;
inline void Block::clear_proposer() {
  proposer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::proposer() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.proposer)
  return proposer_.GetNoArena();
}
inline void Block::set_proposer(const ::std::string& value) {
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.proposer)
}
#if LANG_CXX11
inline void Block::set_proposer(::std::string&& value) {
  
  proposer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.proposer)
}
#endif
inline void Block::set_proposer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.proposer)
}
inline void Block::set_proposer(const void* value, size_t size) {
  
  proposer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.proposer)
}
inline ::std::string* Block::mutable_proposer() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.proposer)
  return proposer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_proposer() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.proposer)
  
  return proposer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_proposer(::std::string* proposer) {
  if (proposer != nullptr) {
    
  } else {
    
  }
  proposer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposer);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.proposer)
}

// string sign = 6;
inline void Block::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::sign() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.sign)
  return sign_.GetNoArena();
}
inline void Block::set_sign(const ::std::string& value) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.sign)
}
#if LANG_CXX11
inline void Block::set_sign(::std::string&& value) {
  
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.sign)
}
#endif
inline void Block::set_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.sign)
}
inline void Block::set_sign(const char* value, size_t size) {
  
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.sign)
}
inline ::std::string* Block::mutable_sign() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_sign() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.sign)
  
  return sign_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_sign(::std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.sign)
}

// bytes pubkey = 7;
inline void Block::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::pubkey() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.pubkey)
  return pubkey_.GetNoArena();
}
inline void Block::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.pubkey)
}
#if LANG_CXX11
inline void Block::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.pubkey)
}
#endif
inline void Block::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.pubkey)
}
inline void Block::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.pubkey)
}
inline ::std::string* Block::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_pubkey() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != nullptr) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.pubkey)
}

// int64 height = 9;
inline void Block::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Block::height() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.height)
  return height_;
}
inline void Block::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.height)
}

// repeated string txids = 11;
inline int Block::txids_size() const {
  return txids_.size();
}
inline void Block::clear_txids() {
  txids_.Clear();
}
inline const ::std::string& Block::txids(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.txids)
  return txids_.Get(index);
}
inline ::std::string* Block::mutable_txids(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.txids)
  return txids_.Mutable(index);
}
inline void Block::set_txids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.txids)
  txids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Block::set_txids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.txids)
  txids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Block::set_txids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.txids)
}
inline void Block::set_txids(int index, const char* value, size_t size) {
  txids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.txids)
}
inline ::std::string* Block::add_txids() {
  // @@protoc_insertion_point(field_add_mutable:xchain.contract.sdk.Block.txids)
  return txids_.Add();
}
inline void Block::add_txids(const ::std::string& value) {
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Block.txids)
}
#if LANG_CXX11
inline void Block::add_txids(::std::string&& value) {
  txids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.Block.txids)
}
#endif
inline void Block::add_txids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  txids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xchain.contract.sdk.Block.txids)
}
inline void Block::add_txids(const char* value, size_t size) {
  txids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xchain.contract.sdk.Block.txids)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Block::txids() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.Block.txids)
  return txids_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Block::mutable_txids() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.Block.txids)
  return &txids_;
}

// int32 tx_count = 12;
inline void Block::clear_tx_count() {
  tx_count_ = 0;
}
inline ::google::protobuf::int32 Block::tx_count() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.tx_count)
  return tx_count_;
}
inline void Block::set_tx_count(::google::protobuf::int32 value) {
  
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.tx_count)
}

// bool in_trunk = 14;
inline void Block::clear_in_trunk() {
  in_trunk_ = false;
}
inline bool Block::in_trunk() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.in_trunk)
  return in_trunk_;
}
inline void Block::set_in_trunk(bool value) {
  
  in_trunk_ = value;
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.in_trunk)
}

// string next_hash = 15;
inline void Block::clear_next_hash() {
  next_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Block::next_hash() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.Block.next_hash)
  return next_hash_.GetNoArena();
}
inline void Block::set_next_hash(const ::std::string& value) {
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.Block.next_hash)
}
#if LANG_CXX11
inline void Block::set_next_hash(::std::string&& value) {
  
  next_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.Block.next_hash)
}
#endif
inline void Block::set_next_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.Block.next_hash)
}
inline void Block::set_next_hash(const char* value, size_t size) {
  
  next_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.Block.next_hash)
}
inline ::std::string* Block::mutable_next_hash() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.Block.next_hash)
  return next_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_next_hash() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.Block.next_hash)
  
  return next_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_next_hash(::std::string* next_hash) {
  if (next_hash != nullptr) {
    
  } else {
    
  }
  next_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_hash);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.Block.next_hash)
}

// -------------------------------------------------------------------

// GetAccountAddressesRequest

// .xchain.contract.sdk.SyscallHeader header = 1;
inline bool GetAccountAddressesRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetAccountAddressesRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::xchain::contract::sdk::SyscallHeader& GetAccountAddressesRequest::header() const {
  const ::xchain::contract::sdk::SyscallHeader* p = header_;
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetAccountAddressesRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::xchain::contract::sdk::SyscallHeader*>(
      &::xchain::contract::sdk::_SyscallHeader_default_instance_);
}
inline ::xchain::contract::sdk::SyscallHeader* GetAccountAddressesRequest::release_header() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetAccountAddressesRequest.header)
  
  ::xchain::contract::sdk::SyscallHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::xchain::contract::sdk::SyscallHeader* GetAccountAddressesRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::xchain::contract::sdk::SyscallHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetAccountAddressesRequest.header)
  return header_;
}
inline void GetAccountAddressesRequest::set_allocated_header(::xchain::contract::sdk::SyscallHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetAccountAddressesRequest.header)
}

// string account = 2;
inline void GetAccountAddressesRequest::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountAddressesRequest::account() const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetAccountAddressesRequest.account)
  return account_.GetNoArena();
}
inline void GetAccountAddressesRequest::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.GetAccountAddressesRequest.account)
}
#if LANG_CXX11
inline void GetAccountAddressesRequest::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xchain.contract.sdk.GetAccountAddressesRequest.account)
}
#endif
inline void GetAccountAddressesRequest::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.GetAccountAddressesRequest.account)
}
inline void GetAccountAddressesRequest::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.GetAccountAddressesRequest.account)
}
inline ::std::string* GetAccountAddressesRequest::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetAccountAddressesRequest.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountAddressesRequest::release_account() {
  // @@protoc_insertion_point(field_release:xchain.contract.sdk.GetAccountAddressesRequest.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountAddressesRequest::set_allocated_account(::std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:xchain.contract.sdk.GetAccountAddressesRequest.account)
}

// -------------------------------------------------------------------

// GetAccountAddressesResponse

// repeated string addresses = 1;
inline int GetAccountAddressesResponse::addresses_size() const {
  return addresses_.size();
}
inline void GetAccountAddressesResponse::clear_addresses() {
  addresses_.Clear();
}
inline const ::std::string& GetAccountAddressesResponse::addresses(int index) const {
  // @@protoc_insertion_point(field_get:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  return addresses_.Get(index);
}
inline ::std::string* GetAccountAddressesResponse::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  return addresses_.Mutable(index);
}
inline void GetAccountAddressesResponse::set_addresses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  addresses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetAccountAddressesResponse::set_addresses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  addresses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetAccountAddressesResponse::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
inline void GetAccountAddressesResponse::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
inline ::std::string* GetAccountAddressesResponse::add_addresses() {
  // @@protoc_insertion_point(field_add_mutable:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  return addresses_.Add();
}
inline void GetAccountAddressesResponse::add_addresses(const ::std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
#if LANG_CXX11
inline void GetAccountAddressesResponse::add_addresses(::std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
#endif
inline void GetAccountAddressesResponse::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
inline void GetAccountAddressesResponse::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
GetAccountAddressesResponse::addresses() const {
  // @@protoc_insertion_point(field_list:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  return addresses_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
GetAccountAddressesResponse::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:xchain.contract.sdk.GetAccountAddressesResponse.addresses)
  return &addresses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace contract
}  // namespace xchain

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_contract_2eproto
